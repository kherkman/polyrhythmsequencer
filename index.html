<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Rhythm Sequencer</title>
    <style>
        :root {
            /* Default Dark Skin */
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --primary-color: #4CAF50; /* Greenish */
            --secondary-color: #2196F3; /* Blue */
            --accent-color: #FFC107; /* Amber */
            --border-color: #333;
            --canvas-bg: #2b2b2b;
            --canvas-line: #999;
            --circle-fill: var(--secondary-color);
            --circle-hit-fill: #ff6347; /* Tomato Red */
            --vertical-line: #FF5252; /* Red Accent */
            --input-bg: #3c3c3c;
            --input-border: #555;
            --hover-bg: #555;
            --button-text: white;
            --play-color: #28a745;
            --stop-color: #dc3545;
            --remove-color: #e74c3c;
            --solo-color: #FFD700; /* Gold */
            --solo-active-text: #333;
            --waveform-color-seq: rgba(0, 255, 0, 0.8); /* Sequencer waveform */
            --waveform-color-global: rgba(0, 191, 255, 0.7); /* Global waveform */
            --global-waveform-bg: #111;
            --slider-track: #555;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Light */
        body.light {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --accent-color: #ffc107;
            --border-color: #ccc;
            --canvas-bg: #e8e8e8;
            --canvas-line: #666;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #dc3545;
            --vertical-line: #dc3545;
            --input-bg: #fff;
            --input-border: #ccc;
            --hover-bg: #e2e6ea;
            --button-text: white;
            --play-color: #28a745;
            --stop-color: #dc3545;
            --remove-color: #dc3545;
            --solo-color: #FFEB3B;
            --solo-active-text: #333;
            --waveform-color-seq: rgba(0, 150, 255, 0.8);
            --waveform-color-global: rgba(0, 100, 200, 0.7);
            --global-waveform-bg: #d0d0d0;
            --slider-track: #bbb;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Blue Wave */
        body.blue-wave {
            --bg-color: #0d1a2b;
            --text-color: #a7d9ff;
            --primary-color: #3f90b5;
            --secondary-color: #2a6f8a;
            --accent-color: #ffeb3b;
            --border-color: #1a3653;
            --canvas-bg: #1c3d5a;
            --canvas-line: #6ba7c6;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #e65100;
            --vertical-line: #ff7043;
            --input-bg: #1a3653;
            --input-border: #2a6f8a;
            --hover-bg: #2a6f8a;
            --button-text: #e0e0e0;
            --play-color: #26a69a;
            --stop-color: #ef5350;
            --remove-color: #ff5252;
            --solo-color: #00BCD4;
            --solo-active-text: #333;
            --waveform-color-seq: rgba(63, 191, 255, 0.8);
            --waveform-color-global: rgba(100, 200, 255, 0.7);
            --global-waveform-bg: #09121a;
            --slider-track: #2a6f8a;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Retro Green */
        body.retro-green {
            --bg-color: #282c34;
            --text-color: #a2f98f;
            --primary-color: #00e676;
            --secondary-color: #69f0ae;
            --accent-color: #ffeb3b;
            --border-color: #4a4d55;
            --canvas-bg: #353942;
            --canvas-line: #7cb342;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #ff9800;
            --vertical-line: #ffab40;
            --input-bg: #4a4d55;
            --input-border: #6d7178;
            --hover-bg: #6d7178;
            --button-text: #282c34;
            --play-color: #26a69a;
            --stop-color: #ff7961;
            --remove-color: #ef5350;
            --solo-color: #CDDC39;
            --solo-active-text: #333;
            --waveform-color-seq: rgba(102, 255, 0, 0.8);
            --waveform-color-global: rgba(50, 200, 0, 0.7);
            --global-waveform-bg: #202025;
            --slider-track: #6d7178;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Cyberpunk */
        body.cyberpunk {
            --bg-color: #0a0a0f;
            --text-color: #00ffc8;
            --primary-color: #ff00ff;
            --secondary-color: #00aaff;
            --accent-color: #ffea00;
            --border-color: #333;
            --canvas-bg: #151520;
            --canvas-line: #76ff03;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: var(--accent-color);
            --vertical-line: #ff2d8d;
            --input-bg: #0d0d14;
            --input-border: #ff00ff;
            --hover-bg: #2a0033;
            --button-text: #000;
            --play-color: #00ffc8;
            --stop-color: #ff00ff;
            --remove-color: #ff3300;
            --solo-color: #39FF14;
            --solo-active-text: #0a0a0f;
            --waveform-color-seq: rgba(0, 255, 200, 0.8);
            --waveform-color-global: rgba(255, 0, 255, 0.7);
            --global-waveform-bg: #050508;
            --slider-track: #ff00ff;
            --slider-thumb: var(--primary-color);
        }
        
        /* Skin: Deep Ocean */
        body.deep-ocean {
            --bg-color: #0f1c2c;
            --text-color: #d1e8ff;
            --primary-color: #1a73e8;
            --secondary-color: #4285f4;
            --accent-color: #ffc107;
            --border-color: #21334c;
            --canvas-bg: #1b2f44;
            --canvas-line: #71b7ff;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #ff6e40;
            --vertical-line: #ff7043;
            --input-bg: #21334c;
            --input-border: #4285f4;
            --hover-bg: #2c415e;
            --button-text: white;
            --play-color: #33d45c;
            --stop-color: #e53935;
            --remove-color: #ef5350;
            --solo-color: #03A9F4;
            --solo-active-text: #333;
            --waveform-color-seq: rgba(90, 200, 250, 0.8);
            --waveform-color-global: rgba(50, 150, 200, 0.7);
            --global-waveform-bg: #0c1824;
            --slider-track: #4285f4;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Brown */
        body.brown {
            --bg-color: #3e2723;
            --text-color: #fbe9e7;
            --primary-color: #a1887f;
            --secondary-color: #d7ccc8;
            --accent-color: #ffb74d;
            --border-color: #5d4037;
            --canvas-bg: #4e342e;
            --canvas-line: #bcaaa4;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #ff7043;
            --vertical-line: #ffab40;
            --input-bg: #5d4037;
            --input-border: #795548;
            --hover-bg: #795548;
            --button-text: white;
            --play-color: #66bb6a;
            --stop-color: #ef5350;
            --remove-color: #ff5252;
            --solo-color: #FFECB3;
            --solo-active-text: #3e2723;
            --waveform-color-seq: rgba(255, 159, 0, 0.8);
            --waveform-color-global: rgba(255, 183, 77, 0.7);
            --global-waveform-bg: #301f1c;
            --slider-track: #795548;
            --slider-thumb: var(--primary-color);
        }

        /* Skin: Orange */
        body.orange {
            --bg-color: #332100;
            --text-color: #fff3e0;
            --primary-color: #ff9800;
            --secondary-color: #fb8c00;
            --accent-color: #ffcc80;
            --border-color: #5c3b00;
            --canvas-bg: #472d00;
            --canvas-line: #ffb74d;
            --circle-fill: var(--primary-color);
            --circle-hit-fill: #ef5350;
            --vertical-line: #ff7043;
            --input-bg: #5c3b00;
            --input-border: #8d6e3f;
            --hover-bg: #8d6e3f;
            --button-text: #332100;
            --play-color: #4CAF50;
            --stop-color: #d32f2f;
            --remove-color: #ff3d00;
            --solo-color: #FFA726;
            --solo-active-text: #332100;
            --waveform-color-seq: rgba(255, 167, 38, 0.8);
            --waveform-color-global: rgba(255, 136, 0, 0.7);
            --global-waveform-bg: #221600;
            --slider-track: #8d6e3f;
            --slider-thumb: var(--primary-color);
        }


        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }
        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
        }
        .global-controls, .sequencer-container {
            width: 100%;
            max-width: 1200px;
            padding: 20px;
            background-color: var(--bg-color);
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
        }
        .global-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            align-items: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            background-color: #222; /* Slightly darker for global controls */
        }
        .sequencer-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 0; /* Individual sequencers will have padding */
            background-color: transparent;
            box-shadow: none;
        }

        .sequencer {
            display: flex;
            flex-wrap: wrap; /* Allow controls to wrap */
            gap: 15px;
            align-items: center;
            padding: 20px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            position: relative;
        }
        .sequencer:hover {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
        }

        .controls-left, .controls-right {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            flex-shrink: 0; /* Prevent shrinking */
            min-width: 180px;
        }
        .sequencer .controls-left { order: 1; }
        .sequencer canvas { order: 2; flex-grow: 1; max-width: 800px; min-width: 300px; }
        .sequencer .controls-right { order: 3; }
        .sequencer .remove-button { order: 4; align-self: center; }

        .sequencer-playback-controls {
            padding: 10px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }


        canvas {
            border: 2px solid var(--border-color);
            background-color: var(--canvas-bg);
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s, border-color 0.3s;
        }
        #globalWaveformCanvas {
            width: 100%;
            height: 80px;
            background-color: var(--global-waveform-bg);
            border: 1px solid var(--border-color);
            margin-top: 10px;
        }

        label {
            font-weight: bold;
            margin-bottom: 3px;
            display: block;
            color: var(--text-color);
            font-size: 0.9em;
        }
        input[type="file"], input[type="text"], input[type="number"], select {
            padding: 8px 10px;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            font-size: 0.9em;
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            width: 150px;
            box-sizing: border-box;
        }
        input[type="file"] {
            width: 100%;
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(var(--primary-color-rgb, 76, 175, 80), 0.25);
        }
        button {
            padding: 10px 18px;
            background-color: var(--primary-color);
            color: var(--button-text);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: var(--hover-bg);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        #globalPlayStopButton {
            background-color: var(--play-color);
        }
        #globalPlayStopButton.stop {
            background-color: var(--stop-color);
        }
        #globalPlayStopButton:hover {
            background-color: var(--play-color); /* Maintain hover */
        }
        #globalPlayStopButton.stop:hover {
            background-color: var(--stop-color); /* Maintain hover */
        }

        .sequencer .play-stop-button {
            background-color: var(--play-color); /* Treat as 'Mute' button, default is 'Unmuted' (Play) */
        }
        .sequencer .play-stop-button.stop {
            background-color: var(--stop-color); /* Muted state */
        }
        .sequencer .play-stop-button:hover {
            filter: brightness(1.1); /* Simple hover effect */
        }

        .sequencer .solo-button {
            background-color: var(--solo-color);
            color: var(--solo-active-text);
        }
        .sequencer .solo-button.active {
            filter: brightness(0.8);
            box-shadow: 0 0 0 2px var(--solo-color), inset 0 0 5px rgba(0,0,0,0.5);
        }
        .sequencer .solo-button:hover {
            filter: brightness(1.1);
        }
        
        .sequencer .remove-button {
            background-color: var(--remove-color);
            padding: 8px 12px;
            font-size: 0.8em;
            margin-left: auto; /* Push to the right */
        }
        .sequencer .remove-button:hover {
            background-color: #c0392b;
        }

        .input-group {
            margin-bottom: 5px;
        }
        .global-waveform-display {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }
        .global-waveform-display label {
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        .file-upload-hidden {
            display: none; /* Hide the actual file input */
        }
        .file-upload-label {
            display: inline-block;
            padding: 8px 10px;
            border: 1px solid var(--input-border);
            border-radius: 5px;
            font-size: 0.9em;
            background-color: var(--input-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: border-color 0.2s, background-color 0.2s, color 0.2s;
            width: 150px;
            box-sizing: border-box;
            text-align: center;
        }
        .file-upload-label:hover {
            border-color: var(--primary-color);
            background-color: var(--hover-bg);
        }

        /* Slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: var(--slider-track);
            border-radius: 5px;
            outline: none;
            margin: 5px 0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: grab;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            transition: background 0.15s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--slider-thumb);
            cursor: grab;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            transition: background 0.15s ease-in-out;
        }
        input[type="range"]:active::-webkit-slider-thumb {
            cursor: grabbing;
        }
        input[type="range"]:active::-moz-range-thumb {
            cursor: grabbing;
        }
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8em;
            color: var(--text-color);
            margin-bottom: 2px;
        }
        .slider-label span {
            font-weight: normal;
            font-style: italic;
        }

        .global-section-header {
            width: 100%;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 15px;
            margin-top: 10px;
            font-size: 1.2em;
            color: var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }
        .global-section-header.collapsible-header {
            cursor: pointer;
            justify-content: space-between;
            padding-right: 15px;
        }
        .collapsible-header .toggle-collapse-button {
            background: none;
            border: none;
            color: var(--text-color);
            font-size: 1.2em;
            cursor: pointer;
            padding: 0;
            margin: 0;
            width: auto; /* Override button width */
            box-shadow: none;
        }
        .collapsible-header .toggle-collapse-button:hover {
            color: var(--primary-color);
            transform: none;
            box-shadow: none;
        }
        .collapsible-content.collapsed {
            display: none;
        }

        #selectedCircleControls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 8px;
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .dynamic-delay-instance {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
            background-color: var(--input-bg);
            border: 1px solid var(--input-border);
            border-radius: 6px;
            margin-top: 10px;
            position: relative;
        }
        .dynamic-delay-instance .remove-button {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 5px 8px;
            font-size: 0.7em;
            margin-left: 0; /* Override default */
            width: auto;
        }


        /* Responsive adjustments */
        @media (max-width: 900px) {
            .sequencer {
                flex-direction: column;
                align-items: stretch;
            }
            .sequencer canvas {
                max-width: 100%;
            }
            .controls-left, .controls-right {
                width: 100%;
                box-sizing: border-box;
                min-width: unset;
            }
            .sequencer .remove-button {
                margin-left: 0;
                width: 100%;
            }
        }
        @media (max-width: 600px) {
            .global-controls, .sequencer {
                padding: 15px;
            }
            button {
                width: 100%;
            }
            input[type="text"], input[type="number"], select {
                width: 100%;
            }
            .file-upload-label {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>Rhythm Sequencer Array</h1>

    <div class="global-controls">
        <div class="input-group">
            <label for="skinSelection">Skin:</label>
            <select id="skinSelection">
                <option value="dark">Dark (Default)</option>
                <option value="light">Light</option>
                <option value="blue-wave">Blue Wave</option>
                <option value="retro-green">Retro Green</option>
                <option value="cyberpunk">Cyberpunk</option>
                <option value="deep-ocean">Deep Ocean</option>
                <option value="brown">Brown</option>
                <option value="orange">Orange</option>
            </select>
        </div>

        <div class="input-group">
            <label for="globalMidiOutDevice">Global MIDI Out Device:</label>
            <select id="globalMidiOutDevice"></select>
        </div>

        <div class="input-group">
            <label for="demoSequences">Demo Sequences:</label>
            <select id="demoSequences">
                <option value="">- Select Demo -</option>
                <option value="0">Demo 1 (Basic Beat)</option>
                <option value="1">Demo 2 (Syncopated)</option>
                <option value="2">Demo 3 (Triplets)</option>
                <option value="3">Demo 4 (Groove)</option>
                <option value="4">Demo 5 (Sparse)</option>
                <option value="5">Demo 6 (Full)</option>
            </select>
        </div>
        
        <button id="addSequencerButton">Add Sequencer</button>
        <button id="generateBeatsButton">Generate Random Beats</button>
        <button id="saveMidiButton">Save to MIDI</button>
        <button id="saveWavButton">Save to WAV</button>
        <button id="saveSettingsButton">Save Settings</button>
        <input type="file" id="loadSettingsFile" class="file-upload-hidden" accept=".json">
        <label for="loadSettingsFile" class="file-upload-label">Load Settings</label>

        <div class="global-section-header">Master Controls</div>
        <div class="input-group">
            <label for="tempoBPM">Tempo (BPM):</label>
            <input type="number" id="tempoBPM" min="30" max="300" value="120">
            <button id="tapTempoButton">Tap Tempo</button>
        </div>
        <div class="input-group">
            <label for="loopBeats">Loop Beats:</label>
            <input type="number" id="loopBeats" min="1" max="16" value="4">
        </div>
        <button id="globalPlayStopButton">Play All</button>

        <div class="input-group" style="width: 250px;">
            <div class="slider-label">
                <label for="masterVolume">Master Volume:</label>
                <span id="masterVolumeValue">75%</span>
            </div>
            <input type="range" id="masterVolume" min="0" max="1" step="0.01" value="0.75">
        </div>


        <div class="global-section-header collapsible-header" data-target="effectsControls">
            Effects
            <button class="toggle-collapse-button" data-target="effectsControls">▲</button>
        </div>
        <div id="effectsControls" class="collapsible-content collapsed">

            <!-- Chorus Controls -->
            <div class="global-section-header">Chorus</div>
            <div class="input-group" style="width: 250px;">
                <button id="chorusOnOffButton" style="background-color: var(--input-bg);">Chorus Off</button>
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="chorusRate">Rate (Hz):</label>
                    <span id="chorusRateValue">1.0 Hz</span>
                </div>
                <input type="range" id="chorusRate" min="0.1" max="10" step="0.1" value="1.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="chorusDepth">Depth:</label>
                    <span id="chorusDepthValue">0.005</span>
                </div>
                <input type="range" id="chorusDepth" min="0.001" max="0.02" step="0.001" value="0.005">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="chorusFeedback">Feedback:</label>
                    <span id="chorusFeedbackValue">0%</span>
                </div>
                <input type="range" id="chorusFeedback" min="0" max="0.9" step="0.01" value="0.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="chorusMix">Mix (Wet):</label>
                    <span id="chorusMixValue">0%</span>
                </div>
                <input type="range" id="chorusMix" min="0" max="1" step="0.01" value="0.0">
            </div>

            <!-- Flanger Controls -->
            <div class="global-section-header">Flanger</div>
            <div class="input-group" style="width: 250px;">
                <button id="flangerOnOffButton" style="background-color: var(--input-bg);">Flanger Off</button>
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="flangerRate">Rate (Hz):</label>
                    <span id="flangerRateValue">0.5 Hz</span>
                </div>
                <input type="range" id="flangerRate" min="0.05" max="5" step="0.05" value="0.5">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="flangerDepth">Depth:</label>
                    <span id="flangerDepthValue">0.002</span>
                </div>
                <input type="range" id="flangerDepth" min="0.0005" max="0.01" step="0.0005" value="0.002">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="flangerFeedback">Feedback:</label>
                    <span id="flangerFeedbackValue">0%</span>
                </div>
                <input type="range" id="flangerFeedback" min="0" max="0.95" step="0.01" value="0.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="flangerMix">Mix (Wet):</label>
                    <span id="flangerMixValue">0%</span>
                </div>
                <input type="range" id="flangerMix" min="0" max="1" step="0.01" value="0.0">
            </div>

            <!-- Phaser Controls -->
            <div class="global-section-header">Phaser</div>
            <div class="input-group" style="width: 250px;">
                <button id="phaserOnOffButton" style="background-color: var(--input-bg);">Phaser Off</button>
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserRate">Rate (Hz):</label>
                    <span id="phaserRateValue">0.2 Hz</span>
                </div>
                <input type="range" id="phaserRate" min="0.01" max="2" step="0.01" value="0.2">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserDepth">Depth:</label>
                    <span id="phaserDepthValue">1.0</span>
                </div>
                <input type="range" id="phaserDepth" min="0" max="1" step="0.01" value="1.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserFeedback">Feedback:</label>
                    <span id="phaserFeedbackValue">0%</span>
                </div>
                <input type="range" id="phaserFeedback" min="0" max="0.95" step="0.01" value="0.0">
            </div>
             <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserFrequency">Frequency (Hz):</label>
                    <span id="phaserFrequencyValue">300 Hz</span>
                </div>
                <input type="range" id="phaserFrequency" min="50" max="2000" step="10" value="300">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserStages">Stages:</label>
                    <span id="phaserStagesValue">4</span>
                </div>
                <input type="number" id="phaserStages" min="2" max="12" value="4">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="phaserMix">Mix (Wet):</label>
                    <span id="phaserMixValue">0%</span>
                </div>
                <input type="range" id="phaserMix" min="0" max="1" step="0.01" value="0.0">
            </div>


            <!-- Reverb Controls -->
            <div class="global-section-header">Reverb</div>
            <div class="input-group" style="width: 250px;">
                <button id="reverbOnOffButton" style="background-color: var(--input-bg);">Reverb Off</button>
            </div>
            <div class="input-group" style="width: 250px;">
                <label for="reverbType">Type:</label>
                <select id="reverbType">
                    <option value="spring">Spring</option>
                    <option value="hall" selected>Hall</option>
                    <option value="cave">Cave</option>
                    <option value="algorithmic">Algorithmic (Custom)</option>
                </select>
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="reverbAmount">Mix (Wet):</label>
                    <span id="reverbAmountValue">0%</span>
                </div>
                <input type="range" id="reverbAmount" min="0" max="1" step="0.01" value="0.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="reverbDecay">Decay Time (s):</label>
                    <span id="reverbDecayValue">1.0s</span>
                </div>
                <input type="range" id="reverbDecay" min="0.1" max="10" step="0.1" value="1.0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="reverbDiffusion">Diffusion:</label>
                    <span id="reverbDiffusionValue">0.50</span>
                </div>
                <input type="range" id="reverbDiffusion" min="0" max="1" step="0.01" value="0.50">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="reverbLowpass">Lowpass (Hz):</label>
                    <span id="reverbLowpassValue">8000 Hz</span>
                </div>
                <input type="range" id="reverbLowpass" min="1000" max="20000" step="100" value="8000">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="reverbHighpass">Highpass (Hz):</label>
                    <span id="reverbHighpassValue">0 Hz</span>
                </div>
                <input type="range" id="reverbHighpass" min="0" max="1000" step="10" value="0">
            </div>

            <!-- Delay Controls -->
            <div class="global-section-header">Delay</div>
            <button id="addDelayButton">Insert Delay</button>
            <div id="dynamicDelayContainer">
                <!-- Default/First Delay Controls - will be moved into dynamic structure or handled by `addDelayInstance` -->
                <!-- The JavaScript will now dynamically add delay instances here -->
            </div>
        </div>

        <div class="global-section-header collapsible-header" data-target="humanizerControls">
            Humanizer Controls
            <button class="toggle-collapse-button" data-target="humanizerControls">▲</button>
        </div>
        <div id="humanizerControls" class="collapsible-content collapsed">
            <div class="input-group" style="width: 250px;">
                <button id="humanizerOnOffButton" style="background-color: var(--input-bg);">Humanizer Off</button>
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="humanizeTiming">Timing Randomness:</label>
                    <span id="humanizeTimingValue">0ms</span>
                </div>
                <input type="range" id="humanizeTiming" min="0" max="100" step="1" value="0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="humanizeVelocity">Velocity Randomness:</label>
                    <span id="humanizeVelocityValue">0%</span>
                </div>
                <input type="range" id="humanizeVelocity" min="0" max="100" step="1" value="0">
            </div>
            <div class="input-group" style="width: 250px;">
                <div class="slider-label">
                    <label for="humanizePan">Pan Randomness:</label>
                    <span id="humanizePanValue">0%</span>
                </div>
                <input type="range" id="humanizePan" min="0" max="100" step="1" value="0">
            </div>
        </div>
        

        <div class="global-waveform-display">
            <label>Global Audio Output Waveform:</label>
            <canvas id="globalWaveformCanvas" width="800" height="80"></canvas>
        </div>
    </div>
    
    <div id="selectedCircleControls" style="display:none;">
        <div class="global-section-header">Selected Circle Controls</div>
        <div class="input-group" style="width: 100%;">
            <label for="circleXPosition">X Position (pixels):</label>
            <input type="number" id="circleXPosition" min="0" max="800" step="1" value="0">
        </div>
        <div class="input-group" style="width: 100%;">
            <label for="circleXRatio">X Ratio (0.0-1.0):</label>
            <input type="number" id="circleXRatio" min="0" max="1" step="0.001" value="0.0">
        </div>
        <div class="input-group" style="width: 100%;">
            <div class="slider-label">
                <label for="circleVelocity">Velocity:</label>
                <span id="circleVelocityValue">100</span>
            </div>
            <input type="range" id="circleVelocity" min="0" max="127" step="1" value="100">
        </div>
        <div class="input-group" style="width: 100%;">
            <div class="slider-label">
                <label for="circlePan">Pan:</label>
                <span id="circlePanValue">0</span>
            </div>
            <input type="range" id="circlePan" min="-100" max="100" step="1" value="0">
        </div>
    </div>

    <div id="sequencerContainer" class="sequencer-container">
        <!-- Sequencer instances will be added here by JavaScript -->
    </div>

    <script>
        // --- Global State and Constants ---
        const sequencerContainer = document.getElementById('sequencerContainer');
        const globalPlayStopButton = document.getElementById('globalPlayStopButton');
        const addSequencerButton = document.getElementById('addSequencerButton');
        const generateBeatsButton = document.getElementById('generateBeatsButton');
        const tempoBPMInput = document.getElementById('tempoBPM');
        const tapTempoButton = document.getElementById('tapTempoButton');
        const skinSelection = document.getElementById('skinSelection');
        const globalMidiOutDeviceSelect = document.getElementById('globalMidiOutDevice');
        const saveMidiButton = document.getElementById('saveMidiButton');
        const saveWavButton = document.getElementById('saveWavButton');
        const saveSettingsButton = document.getElementById('saveSettingsButton');
        const loadSettingsFile = document.getElementById('loadSettingsFile');
        const demoSequencesSelect = document.getElementById('demoSequences');
        const dynamicDelayContainer = document.getElementById('dynamicDelayContainer'); // New container for delays

        // Global Audio Controls
        const masterVolumeSlider = document.getElementById('masterVolume');
        const masterVolumeValueSpan = document.getElementById('masterVolumeValue');
        const loopBeatsInput = document.getElementById('loopBeats');

        // Chorus Controls
        const chorusOnOffButton = document.getElementById('chorusOnOffButton');
        const chorusRateSlider = document.getElementById('chorusRate');
        const chorusRateValueSpan = document.getElementById('chorusRateValue');
        const chorusDepthSlider = document.getElementById('chorusDepth');
        const chorusDepthValueSpan = document.getElementById('chorusDepthValue');
        const chorusFeedbackSlider = document.getElementById('chorusFeedback');
        const chorusFeedbackValueSpan = document.getElementById('chorusFeedbackValue');
        const chorusMixSlider = document.getElementById('chorusMix');
        const chorusMixValueSpan = document.getElementById('chorusMixValue');

        // Flanger Controls
        const flangerOnOffButton = document.getElementById('flangerOnOffButton');
        const flangerRateSlider = document.getElementById('flangerRate');
        const flangerRateValueSpan = document.getElementById('flangerRateValue');
        const flangerDepthSlider = document.getElementById('flangerDepth');
        const flangerDepthValueSpan = document.getElementById('flangerDepthValue');
        const flangerFeedbackSlider = document.getElementById('flangerFeedback');
        const flangerFeedbackValueSpan = document.getElementById('flangerFeedbackValue');
        const flangerMixSlider = document.getElementById('flangerMix');
        const flangerMixValueSpan = document.getElementById('flangerMixValue');

        // Phaser Controls
        const phaserOnOffButton = document.getElementById('phaserOnOffButton');
        const phaserRateSlider = document.getElementById('phaserRate');
        const phaserRateValueSpan = document.getElementById('phaserRateValue');
        const phaserDepthSlider = document.getElementById('phaserDepth');
        const phaserDepthValueSpan = document.getElementById('phaserDepthValue');
        const phaserFeedbackSlider = document.getElementById('phaserFeedback');
        const phaserFeedbackValueSpan = document.getElementById('phaserFeedbackValue');
        const phaserFrequencySlider = document.getElementById('phaserFrequency');
        const phaserFrequencyValueSpan = document.getElementById('phaserFrequencyValue');
        const phaserStagesInput = document.getElementById('phaserStages');
        const phaserStagesValueSpan = document.getElementById('phaserStagesValue');
        const phaserMixSlider = document.getElementById('phaserMix');
        const phaserMixValueSpan = document.getElementById('phaserMixValue');


        // Reverb Controls
        const reverbOnOffButton = document.getElementById('reverbOnOffButton');
        const reverbTypeSelect = document.getElementById('reverbType');
        const reverbAmountSlider = document.getElementById('reverbAmount');
        const reverbAmountValueSpan = document.getElementById('reverbAmountValue');
        const reverbDecaySlider = document.getElementById('reverbDecay');
        const reverbDecayValueSpan = document.getElementById('reverbDecayValue');
        const reverbDiffusionSlider = document.getElementById('reverbDiffusion');
        const reverbDiffusionValueSpan = document.getElementById('reverbDiffusionValue');
        const reverbLowpassSlider = document.getElementById('reverbLowpass');
        const reverbLowpassValueSpan = document.getElementById('reverbLowpassValue');
        const reverbHighpassSlider = document.getElementById('reverbHighpass'); // NEW
        const reverbHighpassValueSpan = document.getElementById('reverbHighpassValue'); // NEW

        // Delay Button
        const addDelayButton = document.getElementById('addDelayButton');

        // Humanizer Controls
        const humanizerControlsDiv = document.getElementById('humanizerControls'); // For collapsing
        const humanizerOnOffButton = document.getElementById('humanizerOnOffButton');
        const humanizeTimingSlider = document.getElementById('humanizeTiming');
        const humanizeTimingValueSpan = document.getElementById('humanizeTimingValue');
        const humanizeVelocitySlider = document.getElementById('humanizeVelocity');
        const humanizeVelocityValueSpan = document.getElementById('humanizeVelocityValue');
        const humanizePanSlider = document = document.getElementById('humanizePan');
        const humanizePanValueSpan = document.getElementById('humanizePanValue');
        
        // Effects Controls Div
        const effectsControlsDiv = document.getElementById('effectsControls');

        // Selected Circle Controls
        const selectedCircleControlsDiv = document.getElementById('selectedCircleControls');
        const circleXPositionInput = document.getElementById('circleXPosition'); // NEW
        const circleXRatioInput = document.getElementById('circleXRatio');     // NEW
        const circleVelocitySlider = document.getElementById('circleVelocity');
        const circleVelocityValueSpan = document.getElementById('circleVelocityValue');
        const circlePanSlider = document.getElementById('circlePan');
        const circlePanValueSpan = document.getElementById('circlePanValue');

        // Global Waveform Display elements
        const globalWaveformCanvas = document.getElementById('globalWaveformCanvas');
        const globalWaveformCtx = globalWaveformCanvas.getContext('2d');

        let activeSequencers = [];
        let isPlayingGlobal = false; // Controls global animation loop
        let globalTempoBPM = parseInt(tempoBPMInput.value);
        let globalLoopBeats = parseInt(loopBeatsInput.value); // NEW: configurable loop length
        let globalBeatDuration = 60 / globalTempoBPM; // Seconds per beat (for 1/4 note)

        let audioContext = null;
        let midiAccess = null;
        let selectedGlobalMidiOutput = null; // The single MIDI output device for all sequencers

        let masterInputMixer = null; // New: All sequencer outputs go here
        let globalAnalyser = null; // Global analyser for overall audio output
        let masterGainNode = null; // Global master volume

        // Chorus Effect Nodes
        let chorusNode = null;
        let chorusOnOffGain = null;
        let chorusWetGainNode = null;
        let isChorusOn = false;

        // Flanger Effect Nodes
        let flangerNode = null;
        let flangerOnOffGain = null;
        let flangerWetGainNode = null;
        let isFlangerOn = false;

        // Phaser Effect Nodes
        let phaserNode = null;
        let phaserOnOffGain = null;
        let phaserWetGainNode = null;
        let isPhaserOn = false;

        // Reverb Effect Nodes
        let reverbNode = null; // Object containing input, output, delays, etc.
        let reverbOnOffGain = null; // Gain node to turn reverb effect on/off
        let reverbWetGainNode = null; // Gain node for reverb mix
        let isReverbOn = false; // Initial state for reverb: OFF
        const defaultReverbType = 'hall';

        // Delay Effect Nodes - now dynamic
        let activeDelayInstances = []; // Array to hold multiple delay instances
        let delayIdCounter = 0; // For unique IDs for dynamic delays
        let isHumanizerOn = false; // Initial state for humanizer: OFF

        let globalWaveformBufferLength = null;
        let globalWaveformDataArray = null;
        let globalWaveformAnimationId = null; // For the global waveform display

        let lastGlobalUpdateTime = 0; // For global deltaTime calculation
        let globalLoopTime = 0; // The shared current time within the loop for all sequencers

        let globalSoloedId = null; // ID of the currently soloed sequencer, null if none
        let preSoloMuteStates = new Map(); // Stores mute state before soloing


        // Current selected circle for individual controls
        let selectedCircle = {
            sequencer: null,
            circleIndex: -1
        };

        // Reverb Presets
        const reverbPresets = {
            'spring':   { decay: 0.8, diffusion: 0.3, lowpass: 6000, highpass: 0, delayTimesFactor: 0.5 },
            'hall':     { decay: 1.5, diffusion: 0.7, lowpass: 9000, highpass: 0, delayTimesFactor: 1.0 },
            'cave':     { decay: 3.0, diffusion: 0.9, lowpass: 4000, highpass: 0, delayTimesFactor: 1.5 },
            'algorithmic': { decay: 1.0, diffusion: 0.5, lowpass: 8000, highpass: 0, delayTimesFactor: 1.0 } // Custom/default algorithmic
        };

        // Sequencer Preset Rhythms (normalized 0-1 ratioX)
        const SEQUENCER_PRESET_RHYTHMS = {
            "off": [],
            "4 on the floor": [
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.25, velocity: 100, pan: 0 },
                { ratioX: 0.5, velocity: 100, pan: 0 },
                { ratioX: 0.75, velocity: 100, pan: 0 }
            ],
            "Hip-hop": [
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.375, velocity: 80, pan: 0 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.875, velocity: 80, pan: 0 }
            ],
            "Funk": [
                { ratioX: 0.0625, velocity: 90, pan: -0.2 },
                { ratioX: 0.25, velocity: 110, pan: 0 },
                { ratioX: 0.5625, velocity: 90, pan: 0.2 },
                { ratioX: 0.75, velocity: 110, pan: 0 }
            ],
            "Swing": [ // Basic 8th note swing feel (long-short pattern)
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.166, velocity: 70, pan: 0 },
                { ratioX: 0.25, velocity: 100, pan: 0 },
                { ratioX: 0.416, velocity: 70, pan: 0 },
                { ratioX: 0.5, velocity: 100, pan: 0 },
                { ratioX: 0.666, velocity: 70, pan: 0 },
                { ratioX: 0.75, velocity: 100, pan: 0 },
                { ratioX: 0.916, velocity: 70, pan: 0 }
            ],
            "Double Beat": [
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.125, velocity: 105, pan: 0 },
                { ratioX: 0.25, velocity: 110, pan: 0 },
                { ratioX: 0.375, velocity: 105, pan: 0 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.625, velocity: 105, pan: 0 },
                { ratioX: 0.75, velocity: 110, pan: 0 },
                { ratioX: 0.875, velocity: 105, pan: 0 }
            ],
            "Reggae": [ // Simplified one-drop with some hi-hat feel
                { ratioX: 0.0, velocity: 100, pan: 0 },   // Kick on 1
                { ratioX: 0.25, velocity: 60, pan: 0 },   // Ghost kick/hi-hat
                { ratioX: 0.5, velocity: 110, pan: 0 },   // Snare on 3
                { ratioX: 0.75, velocity: 70, pan: 0 }    // Kick for push
            ],
            "Blues": [ // Basic shuffle backbeat
                { ratioX: 0.0, velocity: 105, pan: 0 },   // Strong kick on 1
                { ratioX: 0.33, velocity: 90, pan: 0.1 }, // Snare "and" of 2 (swung)
                { ratioX: 0.5, velocity: 95, pan: 0 },    // Kick on 3
                { ratioX: 0.83, velocity: 100, pan: -0.1 } // Snare "and" of 4 (swung)
            ],
            "Jazz": [ // Basic swing ride pattern (ding-da-ding-da)
                { ratioX: 0.0, velocity: 90, pan: 0 },
                { ratioX: 0.33, velocity: 70, pan: 0.2 },
                { ratioX: 0.5, velocity: 90, pan: 0 },
                { ratioX: 0.83, velocity: 70, pan: -0.2 }
            ],
            "D-Beat": [ // Driving punk beat
                { ratioX: 0.0, velocity: 115, pan: 0 }, // Kick 
                { ratioX: 0.125, velocity: 100, pan: 0 }, // Snare 
                { ratioX: 0.1875, velocity: 115, pan: 0 }, // Kick 
                { ratioX: 0.3125, velocity: 100, pan: 0 },  // Kick 
                { ratioX: 0.375, velocity: 115, pan: 0 }, // Snare 
                { ratioX: 0.5, velocity: 100, pan: 0 }, // Kick
                { ratioX: 0.625, velocity: 115, pan: 0 }, // Snare
                { ratioX: 0.6875, velocity: 100, pan: 0 }, // Kick
                { ratioX: 0.8125, velocity: 115, pan: 0 }, // Kick
                { ratioX: 0.875, velocity: 100, pan: 0 }  // Snare
            ],
            "Samba": [ // Syncopated, upbeat feel
                { ratioX: 0.0, velocity: 90, pan: 0 },
                { ratioX: 0.125, velocity: 70, pan: 0.2 },
                { ratioX: 0.375, velocity: 80, pan: -0.2 },
                { ratioX: 0.5, velocity: 95, pan: 0 },
                { ratioX: 0.625, velocity: 65, pan: 0.1 },
                { ratioX: 0.875, velocity: 75, pan: -0.1 }
            ],
            "Bossa Nova": [ // Smooth, syncopated
                { ratioX: 0.0, velocity: 85, pan: 0 },
                { ratioX: 0.25, velocity: 60, pan: 0.2 },
                { ratioX: 0.375, velocity: 75, pan: -0.1 },
                { ratioX: 0.5, velocity: 80, pan: 0 },
                { ratioX: 0.75, velocity: 65, pan: 0.1 },
                { ratioX: 0.875, velocity: 70, pan: -0.2 }
            ],
            "Forró": [ // Upbeat, danceable
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.25, velocity: 85, pan: 0.1 },
                { ratioX: 0.375, velocity: 70, pan: -0.1 },
                { ratioX: 0.5, velocity: 100, pan: 0 },
                { ratioX: 0.75, velocity: 85, pan: 0.1 }
            ],
            "Frevo": [ // Fast, energetic, march-like
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.125, velocity: 90, pan: 0.1 },
                { ratioX: 0.25, velocity: 105, pan: 0 },
                { ratioX: 0.375, velocity: 90, pan: -0.1 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.625, velocity: 90, pan: 0.1 },
                { ratioX: 0.75, velocity: 105, pan: 0 },
                { ratioX: 0.875, velocity: 90, pan: -0.1 }
            ],
            "Maracatu": [ // Slow, heavy, ceremonial
                { ratioX: 0.0, velocity: 120, pan: 0 },
                { ratioX: 0.25, velocity: 80, pan: 0.1 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.75, velocity: 85, pan: -0.1 }
            ],
            "Techno": [ // Driving, repetitive, 4/4 kick focus
                { ratioX: 0.0, velocity: 115, pan: 0 },
                { ratioX: 0.125, velocity: 85, pan: 0.1 }, // off-beat hi-hat/perc
                { ratioX: 0.25, velocity: 110, pan: 0 },
                { ratioX: 0.375, velocity: 80, pan: -0.1 },
                { ratioX: 0.5, velocity: 115, pan: 0 },
                { ratioX: 0.625, velocity: 85, pan: 0.1 },
                { ratioX: 0.75, velocity: 110, pan: 0 },
                { ratioX: 0.875, velocity: 80, pan: -0.1 }
            ],
            "House": [ // Groovy, four-on-the-floor with off-beat hi-hat
                { ratioX: 0.0, velocity: 105, pan: 0 },
                { ratioX: 0.125, velocity: 70, pan: 0.2 },
                { ratioX: 0.25, velocity: 95, pan: 0 },
                { ratioX: 0.375, velocity: 70, pan: -0.2 },
                { ratioX: 0.5, velocity: 105, pan: 0 },
                { ratioX: 0.625, velocity: 70, pan: 0.2 },
                { ratioX: 0.75, velocity: 95, pan: 0 },
                { ratioX: 0.875, velocity: 70, pan: -0.2 }
            ],
            "Dubstep": [ // Syncopated, half-time feel
                { ratioX: 0.0, velocity: 120, pan: 0 },
                { ratioX: 0.25, velocity: 70, pan: 0.1 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.625, velocity: 80, pan: -0.1 },
                { ratioX: 0.75, velocity: 70, pan: 0.1 }
            ],
            "Trap": [ // Fast hi-hats, heavy kick and snare
                { ratioX: 0.0, velocity: 115, pan: 0 },
                { ratioX: 0.0625, velocity: 70, pan: 0.2 },
                { ratioX: 0.125, velocity: 65, pan: -0.2 },
                { ratioX: 0.25, velocity: 100, pan: 0 }, // Snare
                { ratioX: 0.3125, velocity: 70, pan: 0.2 },
                { ratioX: 0.375, velocity: 65, pan: -0.2 },
                { ratioX: 0.5, velocity: 115, pan: 0 },
                { ratioX: 0.5625, velocity: 70, pan: 0.2 },
                { ratioX: 0.625, velocity: 65, pan: -0.2 },
                { ratioX: 0.75, velocity: 100, pan: 0 }, // Snare
                { ratioX: 0.8125, velocity: 70, pan: 0.2 },
                { ratioX: 0.875, velocity: 65, pan: -0.2 }
            ],
            "Trance": [ // Four-on-the-floor, steady with some drive
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.25, velocity: 95, pan: 0 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.75, velocity: 95, pan: 0 }
            ],
            "Drum and Bass": [ // Breakbeat-inspired, fast and syncopated
                { ratioX: 0.0, velocity: 115, pan: 0 },
                { ratioX: 0.1875, velocity: 80, pan: 0.2 },
                { ratioX: 0.375, velocity: 95, pan: -0.2 },
                { ratioX: 0.5, velocity: 105, pan: 0 },
                { ratioX: 0.6875, velocity: 85, pan: 0.2 },
                { ratioX: 0.875, velocity: 90, pan: -0.2 }
            ],
            "Gospel": [ // Complex, syncopated, often swung
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.25, velocity: 80, pan: 0.1 },
                { ratioX: 0.375, velocity: 90, pan: -0.1 },
                { ratioX: 0.5, velocity: 100, pan: 0 },
                { ratioX: 0.75, velocity: 85, pan: 0.1 },
                { ratioX: 0.875, velocity: 95, pan: -0.1 }
            ],
            "Slow Rock": [ // Simple, solid backbeat
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.5, velocity: 110, pan: 0 }
            ],
            "Pop": [ // Catchy, often straightforward
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.25, velocity: 70, pan: 0.1 },
                { ratioX: 0.5, velocity: 95, pan: 0 },
                { ratioX: 0.75, velocity: 75, pan: -0.1 }
            ],
            "Metal": [ // Fast, double bass patterns, driving
                { ratioX: 0.0, velocity: 110, pan: -0.1 },
                { ratioX: 0.0625, velocity: 105, pan: 0.1 },
                { ratioX: 0.125, velocity: 110, pan: -0.1 },
                { ratioX: 0.1875, velocity: 105, pan: 0.1 },
                { ratioX: 0.25, velocity: 115, pan: 0 }, // Snare
                { ratioX: 0.3125, velocity: 105, pan: -0.1 },
                { ratioX: 0.375, velocity: 110, pan: 0.1 },
                { ratioX: 0.4375, velocity: 105, pan: -0.1 },
                { ratioX: 0.5, velocity: 110, pan: 0.1 },
                { ratioX: 0.5625, velocity: 105, pan: -0.1 },
                { ratioX: 0.625, velocity: 110, pan: 0.1 },
                { ratioX: 0.6875, velocity: 105, pan: -0.1 },
                { ratioX: 0.75, velocity: 115, pan: 0 }, // Snare
                { ratioX: 0.8125, velocity: 105, pan: 0.1 },
                { ratioX: 0.875, velocity: 110, pan: -0.1 },
                { ratioX: 0.9375, velocity: 105, pan: 0.1 }
            ],
            "Latin Jazz": [ // Upbeat, clave-influenced
                { ratioX: 0.0, velocity: 90, pan: 0 },
                { ratioX: 0.25, velocity: 75, pan: 0.2 },
                { ratioX: 0.375, velocity: 85, pan: -0.1 },
                { ratioX: 0.5, velocity: 95, pan: 0 },
                { ratioX: 0.625, velocity: 70, pan: 0.1 },
                { ratioX: 0.875, velocity: 80, pan: -0.2 }
            ],
            "Afrobeat": [ // Polyrhythmic, groovy, often 16th-note based
                { ratioX: 0.0, velocity: 105, pan: 0 },
                { ratioX: 0.125, velocity: 70, pan: 0.2 },
                { ratioX: 0.25, velocity: 80, pan: 0 },
                { ratioX: 0.375, velocity: 65, pan: -0.2 },
                { ratioX: 0.5, velocity: 100, pan: 0 },
                { ratioX: 0.625, velocity: 75, pan: 0.2 },
                { ratioX: 0.75, velocity: 85, pan: 0 },
                { ratioX: 0.875, velocity: 60, pan: -0.2 }
            ],
            "Cumbia": [ // Mellow, danceable, often with a slight swing
                { ratioX: 0.0, velocity: 90, pan: 0 },
                { ratioX: 0.25, velocity: 80, pan: 0.1 },
                { ratioX: 0.5, velocity: 95, pan: 0 },
                { ratioX: 0.75, velocity: 75, pan: -0.1 }
            ],
            "Merengue": [ // Fast, energetic, driving
                { ratioX: 0.0, velocity: 110, pan: 0 },
                { ratioX: 0.125, velocity: 90, pan: 0.1 },
                { ratioX: 0.25, velocity: 105, pan: 0 },
                { ratioX: 0.375, velocity: 95, pan: -0.1 },
                { ratioX: 0.5, velocity: 110, pan: 0 },
                { ratioX: 0.625, velocity: 90, pan: 0.1 },
                { ratioX: 0.75, velocity: 105, pan: 0 },
                { ratioX: 0.875, velocity: 95, pan: -0.1 }
            ],
            "Salsa": [ // Complex, syncopated, dance-oriented
                { ratioX: 0.0, velocity: 100, pan: 0 },
                { ratioX: 0.125, velocity: 70, pan: 0.2 },
                { ratioX: 0.25, velocity: 85, pan: -0.1 },
                { ratioX: 0.375, velocity: 75, pan: 0.1 },
                { ratioX: 0.5, velocity: 95, pan: 0 },
                { ratioX: 0.625, velocity: 65, pan: -0.2 },
                { ratioX: 0.75, velocity: 80, pan: 0.1 },
                { ratioX: 0.875, velocity: 70, pan: -0.1 }
            ]
        };


        // --- Preloaded Sounds Data (Paths are relative to index.html) ---
        const preloadedSounds = [
            { name: "Kick", path: "sounds/Kick_01.wav" },
            { name: "Snare", path: "sounds/Snare_01.wav" },
            { name: "Tom High", path: "sounds/Tom_High.wav" },
            { name: "Tom Low", path: "sounds/Tom_Low.wav" },
            { name: "Tom Floor", path: "sounds/Tom_Floor.wav" },
            { name: "Hi-Hat Closed", path: "sounds/Hi-Hat_Closed.wav" },
            { name: "Hi-Hat Open", path: "sounds/Hi-Hat_Open.wav" },
            { name: "Ride", path: "sounds/Ride.wav" },
            { name: "Crash", path: "sounds/Crash.wav" },
            { name: "Clap 1", path: "sounds/Clap_1.wav" },
            { name: "Clap 2", path: "sounds/Clap_2.wav" },
            { name: "Shaker", path: "sounds/Shaker.wav" },
            { name: "Cowbell", path: "sounds/Cowbell.wav" },
            { name: "Conga High", path: "sounds/Conga_High.wav" },
            { name: "Conga Low", path: "sounds/Conga_Low.wav" },
            { name: "Perc 1", path: "sounds/Perc_01.wav" },
            { name: "Perc 2", path: "sounds/Perc_02.wav" },
            { name: "Perc 3", path: "sounds/Perc_03.wav" },
            { name: "Perc 4", path: "sounds/Perc_04.wav" },
            { name: "Perc 5", path: "sounds/Perc_05.wav" },
            { name: "Perc 6", path: "sounds/Perc_06.wav" },
            { name: "Perc 7", path: "sounds/Perc_07.wav" },
            { name: "Perc 8", path: "sounds/Perc_08.wav" },
            { name: "Perc 9", path: "sounds/Perc_09.wav" },
            { name: "Perc 10", path: "sounds/Perc_10.wav" },
            { name: "Perc 11", path: "sounds/Perc_11.wav" },
            { name: "Perc 12", path: "sounds/Perc_12.wav" },
            { name: "Perc 12", path: "sounds/Perc_13.wav" },
            { name: "Perc 14", path: "sounds/Perc_14.wav" },
            { name: "Perc 15", path: "sounds/Perc_15.wav" },
            { name: "Perc 16", path: "sounds/Perc_16.wav" },
            { name: "Perc 17", path: "sounds/Perc_17.wav" },
            { name: "Perc 18", path: "sounds/Perc_18.wav" },
            { name: "Perc 19", path: "sounds/Perc_19.wav" },
            { name: "Perc 20", path: "sounds/Perc_20.wav" },
            { name: "Impact 1", path: "sounds/Impact_1.wav" },
            { name: "Impact 2", path: "sounds/Impact_2.wav" },
            { name: "Impact 3", path: "sounds/Impact_3.wav" },
            { name: "Impact 4", path: "sounds/Impact_4.wav" },
            { name: "Impact 5", path: "sounds/Impact_5.wav" },
            { name: "Impact 6", path: "sounds/Impact_6.wav" },
            { name: "Impact 7", path: "sounds/Impact_7.wav" },
            { name: "Impact 8", path: "sounds/Impact_8.wav" },
            { name: "Impact 9", path: "sounds/Impact_9.wav" },
            
        ];


        // --- Demo Sequences Data ---
        const demoConfigs = [
            // Demo 1 (Basic Beat - More complex)
            {
                tempo: 120, skin: 'dark', globalLoopBeats: 4, masterVolume: 0.75,
                isChorusOn: false, chorusRate: 1.0, chorusDepth: 0.005, chorusFeedback: 0.0, chorusMix: 0.0,
                isFlangerOn: false, flangerRate: 0.5, flangerDepth: 0.002, flangerFeedback: 0.0, flangerMix: 0.0,
                isPhaserOn: false, phaserRate: 0.2, phaserDepth: 1.0, phaserFeedback: 0.0, phaserFrequency: 300, phaserStages: 4, phaserMix: 0.0,
                isReverbOn: false, reverbType: 'hall', reverbAmount: 0.0, reverbDecay: 1.0, reverbDiffusion: 0.5, reverbLowpass: 8000, reverbHighpass: 0,
                delayInstances: [], // Now an array
                isHumanizerOn: false, humanizeTiming: 0, humanizeVelocity: 0, humanizePan: 0,
                humanizerControlsCollapsed: true, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: 4 on the floor with subtle 16th note ghost kicks
                    { id: 1, circles: [{ x: 100, velocity: 105, pan: 0 }, { x: 250, velocity: 60, pan: -0.1 }, { x: 300, velocity: 100, pan: 0 }, { x: 500, velocity: 105, pan: 0 }, { x: 700, velocity: 100, pan: 0 }, { x: 750, velocity: 65, pan: 0.1 }], division: "1/4", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.75, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Clap: On beats 2 and 4, with a lighter ghost clap on the 'and' of 2
                    { id: 2, circles: [{ x: 300, velocity: 95, pan: -0.1 }, { x: 400, velocity: 70, pan: 0.0 }, { x: 700, velocity: 95, pan: 0.1 }], division: "1/4", channel: "2", note: "38", wavFileName: "Clap_1.wav", isMuted: false, volume: 0.6, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            },
            // Demo 2 (Syncopated - More complex)
            {
                tempo: 100, skin: 'blue-wave', globalLoopBeats: 4, masterVolume: 0.75,
                isChorusOn: false, chorusRate: 1.0, chorusDepth: 0.005, chorusFeedback: 0.0, chorusMix: 0.0,
                isFlangerOn: false, flangerRate: 0.5, flangerDepth: 0.002, flangerFeedback: 0.0, flangerMix: 0.0,
                isPhaserOn: false, phaserRate: 0.2, phaserDepth: 1.0, phaserFeedback: 0.0, phaserFrequency: 300, phaserStages: 4, phaserMix: 0.0,
                isReverbOn: true, reverbType: 'hall', reverbAmount: 0.3, reverbDecay: 1.5, reverbDiffusion: 0.6, reverbLowpass: 9000, reverbHighpass: 0,
                delayInstances: [
                    { id: 1, delayTime: 0.75, delayFeedback: 0.6, delayMix: 0.2, delayPan: 0, delayLowpass: 20000, delayHighpass: 0, isDelayOn: true }
                ],
                isHumanizerOn: true, humanizeTiming: 10, humanizeVelocity: 10, humanizePan: 5,
                humanizerControlsCollapsed: false, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: Syncopated pattern with strong 1 and 3, and off-beat accents
                    { id: 1, circles: [{ x: 100, velocity: 110, pan: 0 }, { x: 250, velocity: 80, pan: -0.1 }, { x: 500, velocity: 110, pan: 0 }, { x: 650, velocity: 85, pan: 0.1 }], division: "1/4", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.8, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Clap: Main claps on 2 and 4, with additional 16th note accents
                    { id: 2, circles: [{ x: 300, velocity: 95, pan: -0.2 }, { x: 450, velocity: 80, pan: 0.1 }, { x: 700, velocity: 95, pan: 0.2 }, { x: 850, velocity: 75, pan: -0.1 }], division: "1/8", channel: "2", note: "38", wavFileName: "Clap_1.wav", isMuted: false, volume: 0.7, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Percussion: Intricate 16th note pattern with varied pans and velocities
                    { id: 3, circles: [{ x: 175, velocity: 80, pan: -0.5 }, { x: 225, velocity: 70, pan: -0.3 }, { x: 400, velocity: 80, pan: 0 }, { x: 575, velocity: 80, pan: 0.5 }, { x: 625, velocity: 70, pan: 0.3 }, { x: 800, velocity: 80, pan: 0.7 }], division: "1/8", channel: "3", note: "42", wavFileName: "Perc_01.wav", isMuted: false, volume: 0.5, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            },
            // Demo 3 (Triplets - More complex)
            {
                tempo: 130, skin: 'retro-green', globalLoopBeats: 4, masterVolume: 0.8,
                isChorusOn: false, chorusRate: 1.0, chorusDepth: 0.005, chorusFeedback: 0.0, chorusMix: 0.0,
                isFlangerOn: false, flangerRate: 0.5, flangerDepth: 0.002, flangerFeedback: 0.0, flangerMix: 0.0,
                isPhaserOn: false, phaserRate: 0.2, phaserDepth: 1.0, phaserFeedback: 0.0, phaserFrequency: 300, phaserStages: 4, phaserMix: 0.0,
                isReverbOn: true, reverbType: 'spring', reverbAmount: 0.25, reverbDecay: 0.8, reverbDiffusion: 0.5, reverbLowpass: 6000, reverbHighpass: 0,
                delayInstances: [
                    { id: 1, delayTime: 0.333, delayFeedback: 0.4, delayMix: 0.1, delayPan: 0, delayLowpass: 20000, delayHighpass: 0, isDelayOn: true }
                ],
                isHumanizerOn: false, humanizeTiming: 5, humanizeVelocity: 5, humanizePan: 0,
                humanizerControlsCollapsed: true, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: Triplet pattern with strong accents and some subtle off-triplet hits
                    { id: 1, circles: [{ x: 100, velocity: 100, pan: 0 }, { x: 233, velocity: 80, pan: -0.1 }, { x: 500, velocity: 100, pan: 0 }, { x: 633, velocity: 85, pan: 0.1 }, { x: 767, velocity: 70, pan: 0.2 }], division: "1/3", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.7, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Conga: Active triplet pattern with varied velocities and pans
                    { id: 2, circles: [{ x: 167, velocity: 85, pan: -0.4 }, { x: 300, velocity: 90, pan: 0 }, { x: 433, velocity: 80, pan: 0.4 }, { x: 567, velocity: 85, pan: -0.2 }, { x: 700, velocity: 90, pan: 0.2 }, { x: 833, velocity: 80, pan: 0.5 }], division: "1/3", channel: "2", note: "38", wavFileName: "Conga_High.wav", isMuted: false, volume: 0.65, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            },
            // Demo 4 (Groove - More complex)
            {
                tempo: 90, skin: 'deep-ocean', globalLoopBeats: 4, masterVolume: 0.75,
                isChorusOn: false, chorusRate: 1.0, chorusDepth: 0.005, chorusFeedback: 0.0, chorusMix: 0.0,
                isFlangerOn: false, flangerRate: 0.5, flangerDepth: 0.002, flangerFeedback: 0.0, flangerMix: 0.0,
                isPhaserOn: false, phaserRate: 0.2, phaserDepth: 1.0, phaserFeedback: 0.0, phaserFrequency: 300, phaserStages: 4, phaserMix: 0.0,
                isReverbOn: true, reverbType: 'cave', reverbAmount: 0.4, reverbDecay: 2.0, reverbDiffusion: 0.7, reverbLowpass: 4000, reverbHighpass: 0,
                delayInstances: [
                    { id: 1, delayTime: 1.0, delayFeedback: 0.7, delayMix: 0.4, delayPan: 0, delayLowpass: 20000, delayHighpass: 0, isDelayOn: true }
                ],
                isHumanizerOn: true, humanizeTiming: 15, humanizeVelocity: 15, humanizePan: 10,
                humanizerControlsCollapsed: false, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: Groove-oriented kick with syncopated 16th notes
                    { id: 1, circles: [{ x: 100, velocity: 110, pan: 0 }, { x: 250, velocity: 70, pan: -0.1 }, { x: 400, velocity: 80, pan: 0 }, { x: 500, velocity: 110, pan: 0 }, { x: 750, velocity: 75, pan: 0.1 }], division: "1/4", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.8, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Clap: Slightly delayed backbeats for a laid-back feel
                    { id: 2, circles: [{ x: 325, velocity: 90, pan: -0.2 }, { x: 725, velocity: 90, pan: 0.2 }], division: "1/4", channel: "2", note: "38", wavFileName: "Clap_1.wav", isMuted: false, volume: 0.6, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Percussion 1: More varied and dense 8th and 16th note patterns
                    { id: 3, circles: [{ x: 200, velocity: 85, pan: -0.5 }, { x: 300, velocity: 75, pan: -0.1 }, { x: 400, velocity: 80, pan: 0.1 }, { x: 500, velocity: 85, pan: 0.5 }, { x: 600, velocity: 75, pan: 0.3 }, { x: 700, velocity: 80, pan: 0.7 }, { x: 800, velocity: 70, pan: 0.9 }], division: "1/8", channel: "3", note: "42", wavFileName: "Perc_01.wav", isMuted: false, volume: 0.5, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Percussion 2: Active fills and syncopated hits
                    { id: 4, circles: [{ x: 125, velocity: 70, pan: -0.7 }, { x: 375, velocity: 65, pan: -0.3 }, { x: 525, velocity: 70, pan: 0.7 }, { x: 775, velocity: 65, pan: 0.3 }], division: "1/8", channel: "4", note: "45", wavFileName: "Conga_Low.wav", isMuted: false, volume: 0.5, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            },
            // Demo 5 (Sparse - More complex placement)
            {
                tempo: 110, skin: 'cyberpunk', globalLoopBeats: 4, masterVolume: 0.85,
                isChorusOn: false, chorusRate: 1.0, chorusDepth: 0.005, chorusFeedback: 0.0, chorusMix: 0.0,
                isFlangerOn: false, flangerRate: 0.5, flangerDepth: 0.002, flangerFeedback: 0.0, flangerMix: 0.0,
                isPhaserOn: false, phaserRate: 0.2, phaserDepth: 1.0, phaserFeedback: 0.0, phaserFrequency: 300, phaserStages: 4, phaserMix: 0.0,
                isReverbOn: true, reverbType: 'hall', reverbAmount: 0.1, reverbDecay: 0.8, reverbDiffusion: 0.4, reverbLowpass: 7000, reverbHighpass: 0,
                delayInstances: [
                    { id: 1, delayTime: 0.25, delayFeedback: 0.3, delayMix: 0.15, delayPan: 0, delayLowpass: 20000, delayHighpass: 0, isDelayOn: true }
                ],
                isHumanizerOn: false, humanizeTiming: 0, humanizeVelocity: 0, humanizePan: 0,
                humanizerControlsCollapsed: true, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: Strong downbeat with a syncopated off-beat hit
                    { id: 1, circles: [{ x: 100, velocity: 120, pan: 0 }, { x: 550, velocity: 90, pan: 0.1 }], division: "1/2", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.9, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Clap: A slightly early clap and a late one, adding tension
                    { id: 2, circles: [{ x: 375, velocity: 100, pan: -0.1 }, { x: 825, velocity: 80, pan: 0.1 }], division: "1/2", channel: "2", note: "38", wavFileName: "Clap_1.wav", isMuted: false, volume: 0.7, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Percussion: Subtle, well-placed early and late hits
                    { id: 3, circles: [{ x: 275, velocity: 60, pan: -0.1 }, { x: 725, velocity: 80, pan: 0.1 }], division: "1/2", channel: "3", note: "42", wavFileName: "Perc_01.wav", isMuted: false, volume: 0.6, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            },
            // Demo 6 (Full - Significantly more complex)
            {
                tempo: 140, skin: 'light', globalLoopBeats: 4, masterVolume: 0.7,
                isChorusOn: true, chorusRate: 1.5, chorusDepth: 0.01, chorusFeedback: 0.2, chorusMix: 0.1,
                isFlangerOn: true, flangerRate: 0.3, flangerDepth: 0.003, flangerFeedback: 0.3, flangerMix: 0.15,
                isPhaserOn: true, phaserRate: 0.4, phaserDepth: 0.8, phaserFeedback: 0.4, phaserFrequency: 500, phaserStages: 6, phaserMix: 0.1,
                isReverbOn: true, reverbType: 'hall', reverbAmount: 0.35, reverbDecay: 1.8, reverbDiffusion: 0.65, reverbLowpass: 10000, reverbHighpass: 0,
                delayInstances: [
                    { id: 1, delayTime: 0.5, delayFeedback: 0.55, delayMix: 0.25, delayPan: 0.1, delayLowpass: 15000, delayHighpass: 100, isDelayOn: true }
                ],
                isHumanizerOn: true, humanizeTiming: 8, humanizeVelocity: 8, humanizePan: 4,
                humanizerControlsCollapsed: false, effectsControlsCollapsed: false,
                sequencers: [
                    // Kick: Dense pattern with 4 on the floor base and numerous 16th note ghost kicks
                    { id: 1, circles: [{ x: 100, velocity: 105, pan: 0 }, { x: 250, velocity: 70, pan: -0.1 }, { x: 300, velocity: 100, pan: 0 }, { x: 450, velocity: 65, pan: 0.1 }, { x: 500, velocity: 105, pan: 0 }, { x: 650, velocity: 70, pan: -0.1 }, { x: 700, velocity: 100, pan: 0 }, { x: 850, velocity: 65, pan: 0.1 }], division: "1/4", channel: "1", note: "36", wavFileName: "Kick_01.wav", isMuted: false, volume: 0.75, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Clap: Solid backbeat on beats 2 and 4
                    { id: 2, circles: [{ x: 300, velocity: 90, pan: -0.2 }, { x: 700, velocity: 90, pan: 0.2 }], division: "1/4", channel: "2", note: "38", wavFileName: "Clap_1.wav", isMuted: false, volume: 0.6, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Conga High: Intricate 16th note pattern with varied velocities and panning
                    { id: 3, circles: [{ x: 150, velocity: 85, pan: -0.5 }, { x: 200, velocity: 75, pan: -0.3 }, { x: 350, velocity: 85, pan: -0.1 }, { x: 400, velocity: 75, pan: 0.1 }, { x: 550, velocity: 85, pan: 0.1 }, { x: 600, velocity: 75, pan: 0.3 }, { x: 750, velocity: 85, pan: 0.5 }, { x: 800, velocity: 75, pan: 0.7 }], division: "1/8", channel: "3", note: "42", wavFileName: "Conga_High.wav", isMuted: false, volume: 0.5, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Conga Low: Syncopated 16th note fills, creating rhythmic interplay
                    { id: 4, circles: [{ x: 225, velocity: 70, pan: -0.7 }, { x: 375, velocity: 60, pan: -0.3 }, { x: 475, velocity: 65, pan: -0.1 }, { x: 625, velocity: 70, pan: 0.7 }, { x: 775, velocity: 60, pan: 0.3 }, { x: 875, velocity: 65, pan: 0.1 }], division: "1/16", channel: "4", note: "45", wavFileName: "Conga_Low.wav", isMuted: false, volume: 0.5, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" },
                    // Perc_01: Very dense 16th note roll with dynamic velocities and sweeping pans
                    { id: 5, circles: [{ x: 125, velocity: 60, pan: -0.8 }, { x: 175, velocity: 55, pan: -0.7 }, { x: 225, velocity: 60, pan: -0.6 }, { x: 275, velocity: 55, pan: -0.5 }, { x: 325, velocity: 60, pan: -0.4 }, { x: 375, velocity: 55, pan: -0.3 }, { x: 425, velocity: 60, pan: -0.2 }, { x: 475, velocity: 55, pan: -0.1 }, { x: 525, velocity: 60, pan: 0.1 }, { x: 575, velocity: 55, pan: 0.2 }, { x: 625, velocity: 60, pan: 0.3 }, { x: 675, velocity: 55, pan: 0.4 }, { x: 725, velocity: 60, pan: 0.5 }, { x: 775, velocity: 55, pan: 0.6 }, { x: 825, velocity: 60, pan: 0.7 }, { x: 875, velocity: 55, pan: 0.8 }], division: "1/16", channel: "5", note: "49", wavFileName: "Perc_01.wav", isMuted: false, volume: 0.4, pan: 0, phase: 0, editMode: "add", presetRhythm: "off" }
                ]
            }
        ];

        // --- Tap Tempo Logic ---
        let tapTimes = [];
        const TAP_THRESHOLD = 2000; // ms to reset tap tempo if no new tap
        function handleTapTempo() {
            const now = performance.now();
            if (tapTimes.length > 0 && now - tapTimes[tapTimes.length - 1] > TAP_THRESHOLD) {
                tapTimes = []; // Reset if too long between taps
            }
            tapTimes.push(now);

            if (tapTimes.length >= 2) {
                const totalInterval = tapTimes[tapTimes.length - 1] - tapTimes[0];
                const averageInterval = totalInterval / (tapTimes.length - 1);
                const newBPM = Math.round(60000 / averageInterval); // 60000ms in a minute
                tempoBPMInput.value = newBPM;
                updateGlobalTempo();
                console.log(`Tap Tempo: ${newBPM} BPM`);

                if (tapTimes.length > 8) { // Keep a reasonable number of taps for accuracy
                    tapTimes.shift();
                }
            }
        }

        // --- Utility Functions ---
        function parseFraction(fractionStr) {
            if (fractionStr.includes('/')) {
                const parts = fractionStr.split('/');
                if (parts.length === 2) {
                    const numerator = parseFloat(parts[0]);
                    const denominator = parseFloat(parts[1]);
                    if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
                        return numerator / denominator;
                    }
                }
            } else {
                const decimal = parseFloat(fractionStr);
                if (!isNaN(decimal)) {
                    return decimal;
                }
            }
            return null; // Invalid input
        }

        function downloadFile(data, filename, type) {
            const blob = new Blob([data], { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function varCSS(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName);
        }

        // Helper to convert hex to RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        // --- Global Audio Context ---
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                masterInputMixer = audioContext.createGain(); // Collects all sequencer outputs

                // Analyser connects to the final output for visualization
                globalAnalyser = audioContext.createAnalyser();
                globalAnalyser.fftSize = 2048;
                globalWaveformBufferLength = globalAnalyser.frequencyBinCount;
                globalWaveformDataArray = new Uint8Array(globalWaveformBufferLength);

                // Master Gain (connects to destination)
                masterGainNode = audioContext.createGain();
                masterGainNode.gain.value = parseFloat(masterVolumeSlider.value);
                masterVolumeValueSpan.textContent = `${(masterGainNode.gain.value * 100).toFixed(0)}%`;

                // Chain: Master Input -> Chorus -> Flanger -> Phaser -> (Reverb & Delays Parallel) -> Master Gain -> Analyser -> Destination
                // A simplified parallel wet mix approach for all effects connected to masterInputMixer:

                masterInputMixer.connect(masterGainNode); // Dry signal directly to master

                // Chorus Effect Setup
                chorusNode = createChorusEffect(audioContext);
                chorusOnOffGain = audioContext.createGain();
                chorusWetGainNode = audioContext.createGain();
                masterInputMixer.connect(chorusOnOffGain); // Input to chorus gate
                chorusOnOffGain.connect(chorusNode.input); // Gate to chorus input
                chorusNode.output.connect(chorusWetGainNode); // Chorus output to wet gain
                chorusWetGainNode.connect(masterGainNode); // Wet gain to master
                chorusOnOffGain.gain.value = isChorusOn ? 1 : 0;
                chorusOnOffButton.textContent = isChorusOn ? 'Chorus On' : 'Chorus Off';
                chorusOnOffButton.style.backgroundColor = isChorusOn ? varCSS('--primary-color') : varCSS('--input-bg');


                // Flanger Effect Setup
                flangerNode = createFlangerEffect(audioContext);
                flangerOnOffGain = audioContext.createGain();
                flangerWetGainNode = audioContext.createGain();
                masterInputMixer.connect(flangerOnOffGain); // Input to flanger gate
                flangerOnOffGain.connect(flangerNode.input); // Gate to flanger input
                flangerNode.output.connect(flangerWetGainNode); // Flanger output to wet gain
                flangerWetGainNode.connect(masterGainNode); // Wet gain to master
                flangerOnOffGain.gain.value = isFlangerOn ? 1 : 0;
                flangerOnOffButton.textContent = isFlangerOn ? 'Flanger On' : 'Flanger Off';
                flangerOnOffButton.style.backgroundColor = isFlangerOn ? varCSS('--primary-color') : varCSS('--input-bg');


                // Phaser Effect Setup
                phaserNode = createPhaserEffect(audioContext);
                phaserOnOffGain = audioContext.createGain();
                phaserWetGainNode = audioContext.createGain();
                masterInputMixer.connect(phaserOnOffGain); // Input to phaser gate
                phaserOnOffGain.connect(phaserNode.input); // Gate to phaser input
                phaserNode.output.connect(phaserWetGainNode); // Phaser output to wet gain
                phaserWetGainNode.connect(masterGainNode); // Wet gain to master
                phaserOnOffGain.gain.value = isPhaserOn ? 1 : 0;
                phaserOnOffButton.textContent = isPhaserOn ? 'Phaser On' : 'Phaser Off';
                phaserOnOffButton.style.backgroundColor = isPhaserOn ? varCSS('--primary-color') : varCSS('--input-bg');


                // Reverb Effect Setup (parallel to other effects, receives from masterInputMixer)
                reverbNode = createAlgorithmicReverb(audioContext); // Returns {input, output, delays, feedbackGains, filters, highpassFilter}
                reverbOnOffGain = audioContext.createGain();
                reverbWetGainNode = audioContext.createGain();
                masterInputMixer.connect(reverbOnOffGain); // Input to reverb gate
                reverbOnOffGain.connect(reverbNode.input); // Gate to reverb input
                reverbNode.output.connect(reverbWetGainNode); // Reverb wet output to wet mix gain
                reverbWetGainNode.connect(masterGainNode); // Wet mix gain to master
                reverbOnOffGain.gain.value = isReverbOn ? 1 : 0;
                reverbOnOffButton.textContent = isReverbOn ? 'Reverb On' : 'Reverb Off';
                reverbOnOffButton.style.backgroundColor = isReverbOn ? varCSS('--primary-color') : varCSS('--input-bg');

                // Master output chain
                masterGainNode.connect(globalAnalyser); // Analyze final mixed output
                globalAnalyser.connect(audioContext.destination);

                // Update initial display values for sliders and buttons
                updateChorusControls();
                updateFlangerControls();
                updatePhaserControls();
                updateReverbControls(); // This will also set reverbWetGainNode.gain.value
                updateHumanizerControls(); // Initial display

                startGlobalWaveformDrawing();
            }
            return audioContext;
        }

        // --- Chorus Effect ---
        function createChorusEffect(context) {
            const input = context.createGain();
            const output = context.createGain();

            const delay = context.createDelay(0.1); // Max delay
            const lfo = context.createOscillator();
            const lfoGain = context.createGain();
            const feedback = context.createGain();

            delay.delayTime.value = 0.005; // Base delay

            lfo.frequency.value = 1.0; // Default rate
            lfoGain.gain.value = 0.005; // Default depth

            lfo.connect(lfoGain);
            lfoGain.connect(delay.delayTime);

            input.connect(delay);
            delay.connect(feedback);
            feedback.connect(delay); // Feedback loop
            delay.connect(output);

            lfo.start(0);

            return { input, output, delay, lfo, lfoGain, feedback };
        }

        function updateChorusControls() {
            if (!chorusNode) return;

            const rate = parseFloat(chorusRateSlider.value);
            const depth = parseFloat(chorusDepthSlider.value);
            const feedback = parseFloat(chorusFeedbackSlider.value);
            const mix = parseFloat(chorusMixSlider.value);

            chorusNode.lfo.frequency.value = rate;
            chorusNode.lfoGain.gain.value = depth;
            chorusNode.feedback.gain.value = feedback;
            chorusWetGainNode.gain.value = mix;

            chorusRateValueSpan.textContent = `${rate.toFixed(1)} Hz`;
            chorusDepthValueSpan.textContent = `${depth.toFixed(3)}`;
            chorusFeedbackValueSpan.textContent = `${(feedback * 100).toFixed(0)}%`;
            chorusMixValueSpan.textContent = `${(mix * 100).toFixed(0)}%`;
        }

        function toggleChorus() {
            isChorusOn = !isChorusOn;
            if (chorusOnOffGain) {
                chorusOnOffGain.gain.value = isChorusOn ? 1 : 0;
                chorusOnOffButton.textContent = isChorusOn ? 'Chorus On' : 'Chorus Off';
                chorusOnOffButton.style.backgroundColor = isChorusOn ? varCSS('--primary-color') : varCSS('--input-bg');
            }
        }

        // --- Flanger Effect ---
        function createFlangerEffect(context) {
            const input = context.createGain();
            const output = context.createGain();

            const delay = context.createDelay(0.1); // Max delay
            const lfo = context.createOscillator();
            const lfoGain = context.createGain();
            const feedback = context.createGain();

            delay.delayTime.value = 0.002; // Base delay

            lfo.frequency.value = 0.5; // Default rate
            lfoGain.gain.value = 0.002; // Default depth

            lfo.connect(lfoGain);
            lfoGain.connect(delay.delayTime);

            input.connect(delay);
            delay.connect(feedback);
            feedback.connect(delay); // Feedback loop
            delay.connect(output);

            lfo.start(0);

            return { input, output, delay, lfo, lfoGain, feedback };
        }

        function updateFlangerControls() {
            if (!flangerNode) return;

            const rate = parseFloat(flangerRateSlider.value);
            const depth = parseFloat(flangerDepthSlider.value);
            const feedback = parseFloat(flangerFeedbackSlider.value);
            const mix = parseFloat(flangerMixSlider.value);

            flangerNode.lfo.frequency.value = rate;
            flangerNode.lfoGain.gain.value = depth;
            flangerNode.feedback.gain.value = feedback;
            flangerWetGainNode.gain.value = mix;

            flangerRateValueSpan.textContent = `${rate.toFixed(2)} Hz`;
            flangerDepthValueSpan.textContent = `${depth.toFixed(4)}`;
            flangerFeedbackValueSpan.textContent = `${(feedback * 100).toFixed(0)}%`;
            flangerMixValueSpan.textContent = `${(mix * 100).toFixed(0)}%`;
        }

        function toggleFlanger() {
            isFlangerOn = !isFlangerOn;
            if (flangerOnOffGain) {
                flangerOnOffGain.gain.value = isFlangerOn ? 1 : 0;
                flangerOnOffButton.textContent = isFlangerOn ? 'Flanger On' : 'Flanger Off';
                flangerOnOffButton.style.backgroundColor = isFlangerOn ? varCSS('--primary-color') : varCSS('--input-bg');
            }
        }

        // --- Phaser Effect ---
        function createPhaserEffect(context) {
            const input = context.createGain();
            const output = context.createGain();

            const lfo = context.createOscillator();
            lfo.frequency.value = 0.2; // Default rate
            lfo.type = 'sine';
            lfo.start(0);

            const filters = [];
            const numStages = parseInt(phaserStagesInput.value); // Default 4 stages
            const feedback = context.createGain();
            feedback.gain.value = 0.0; // Default feedback

            let lastFilter = input;
            for (let i = 0; i < numStages; i++) {
                const filter = context.createBiquadFilter();
                filter.type = 'allpass';
                filter.frequency.value = parseFloat(phaserFrequencySlider.value); // Base frequency
                filter.Q.value = 1; // Resonant quality
                lfo.connect(filter.detune); // LFO controls detune for sweeping effect
                lastFilter.connect(filter);
                filters.push(filter);
                lastFilter = filter;
            }

            // Connect dry signal in parallel for mixing
            input.connect(output);
            
            // Connect last filter output to output, and also to feedback
            lastFilter.connect(output);
            lastFilter.connect(feedback);
            feedback.connect(filters[0]); // Feedback to first allpass filter

            return { input, output, lfo, filters, feedback };
        }

        function updatePhaserControls() {
            if (!phaserNode) return;

            const rate = parseFloat(phaserRateSlider.value);
            const depth = parseFloat(phaserDepthSlider.value);
            const feedback = parseFloat(phaserFeedbackSlider.value);
            const frequency = parseFloat(phaserFrequencySlider.value);
            const stages = parseInt(phaserStagesInput.value);
            const mix = parseFloat(phaserMixSlider.value);

            phaserNode.lfo.frequency.value = rate;
            // Detune is controlled by LFO directly, so adjust LFO gain for depth
            phaserNode.filters.forEach(filter => {
                filter.frequency.value = frequency;
                filter.detune.value = 100 * depth; // Control how much LFO affects frequency
            });
            phaserNode.feedback.gain.value = feedback;
            phaserWetGainNode.gain.value = mix;

            phaserRateValueSpan.textContent = `${rate.toFixed(2)} Hz`;
            phaserDepthValueSpan.textContent = `${depth.toFixed(1)}`;
            phaserFeedbackValueSpan.textContent = `${(feedback * 100).toFixed(0)}%`;
            phaserFrequencyValueSpan.textContent = `${frequency} Hz`;
            phaserStagesValueSpan.textContent = `${stages}`; // No actual stages control, just for display
            phaserMixValueSpan.textContent = `${(mix * 100).toFixed(0)}%`;

            // If stages changed, need to rebuild phaser (too complex for real-time)
            if (phaserNode.filters.length !== stages) {
                console.warn("Phaser stages can only be set on initialization. Change will not apply until page refresh or re-instantiate effect.");
            }
        }

        function togglePhaser() {
            isPhaserOn = !isPhaserOn;
            if (phaserOnOffGain) {
                phaserOnOffGain.gain.value = isPhaserOn ? 1 : 0;
                phaserOnOffButton.textContent = isPhaserOn ? 'Phaser On' : 'Phaser Off';
                phaserOnOffButton.style.backgroundColor = isPhaserOn ? varCSS('--primary-color') : varCSS('--input-bg');
            }
        }


        // --- Algorithmic Reverb Function ---
        const baseReverbDelayTimes = [0.013, 0.029, 0.037, 0.053, 0.067, 0.071]; // Prime numbers for better diffusion
        function createAlgorithmicReverb(context) {
            const input = context.createGain(); // Input from masterInputMixer
            const output = context.createGain(); // Pure wet output
            
            // FDN structure to produce the wet signal
            const delays = [];
            const feedbackGains = [];
            const lowpassFilters = [];
            const highpassFilter = context.createBiquadFilter(); // NEW highpass
            highpassFilter.type = 'highpass';
            highpassFilter.frequency.value = 0; // Default

            input.connect(highpassFilter); // NEW: Highpass filter at input
            let currentInput = highpassFilter;

            const numDelays = baseReverbDelayTimes.length;
            for (let i = 0; i < numDelays; i++) {
                const delay = context.createDelay(10.0); // Max delay time (longer than max decay)
                const feedbackGain = context.createGain();
                const lowpassFilter = context.createBiquadFilter();
                lowpassFilter.type = 'lowpass';
                lowpassFilter.frequency.value = 8000; // Default

                currentInput.connect(delay); // Connect after highpass or previous filter
                delay.connect(lowpassFilter); // LPF in feedback path
                lowpassFilter.connect(feedbackGain);
                feedbackGain.connect(delay);
                delay.connect(output); // Sum outputs to this master output

                delays.push(delay);
                feedbackGains.push(feedbackGain);
                lowpassFilters.push(lowpassFilter);
            }

            return { input, output, delays, feedbackGains, lowpassFilters, highpassFilter }; // Added highpassFilter
        }

        function updateReverbControls() {
            if (!reverbNode) return;

            let mix = parseFloat(reverbAmountSlider.value);
            let decay = parseFloat(reverbDecaySlider.value);
            let diffusion = parseFloat(reverbDiffusionSlider.value);
            let lowpassFreq = parseFloat(reverbLowpassSlider.value);
            let highpassFreq = parseFloat(reverbHighpassSlider.value); // NEW
            let delayTimesFactor = 1.0;

            const selectedType = reverbTypeSelect.value;
            if (selectedType !== 'algorithmic') {
                const preset = reverbPresets[selectedType];
                if (preset) {
                    // Update sliders visually from preset, but use the preset values for audio engine
                    reverbDecaySlider.value = preset.decay;
                    reverbDiffusionSlider.value = preset.diffusion;
                    reverbLowpassSlider.value = preset.lowpass;
                    reverbHighpassSlider.value = preset.highpass; // NEW

                    decay = preset.decay;
                    diffusion = preset.diffusion;
                    lowpassFreq = preset.lowpass;
                    highpassFreq = preset.highpass; // NEW
                    delayTimesFactor = preset.delayTimesFactor;
                }
            }

            reverbWetGainNode.gain.value = mix;

            reverbNode.lowpassFilters.forEach(filter => filter.frequency.value = lowpassFreq);
            reverbNode.highpassFilter.frequency.value = highpassFreq; // NEW: Apply highpass

            reverbNode.feedbackGains.forEach((fb) => {
                fb.gain.value = 0.4 + (decay / 10) * 0.5; // Scaled for new max decay
                fb.gain.value = Math.min(0.98, Math.max(0.01, fb.gain.value)); // Clamp
            });
            reverbNode.delays.forEach((delay, i) => {
                // Adjust delay times slightly based on diffusion
                delay.delayTime.value = baseReverbDelayTimes[i] * delayTimesFactor * (1 + (diffusion * 0.5 * (Math.random() - 0.5)));
            });

            reverbAmountValueSpan.textContent = `${(mix * 100).toFixed(0)}%`;
            reverbDecayValueSpan.textContent = `${decay.toFixed(1)}s`;
            reverbDiffusionValueSpan.textContent = `${diffusion.toFixed(2)}`;
            reverbLowpassValueSpan.textContent = `${lowpassFreq} Hz`;
            reverbHighpassValueSpan.textContent = `${highpassFreq} Hz`; // NEW
        }

        function toggleReverb() {
            isReverbOn = !isReverbOn;
            if (reverbOnOffGain) {
                reverbOnOffGain.gain.value = isReverbOn ? 1 : 0;
                reverbOnOffButton.textContent = isReverbOn ? 'Reverb On' : 'Reverb Off';
                reverbOnOffButton.style.backgroundColor = isReverbOn ? varCSS('--primary-color') : varCSS('--input-bg');
            }
        }

        // --- Delay Effect Function ---
        function createDelayEffect(context) {
            const input = context.createGain(); // Input from masterInputMixer
            const output = context.createGain(); // Pure wet output
            
            const delay = context.createDelay(4.0); // Max delay of 4 seconds
            const feedbackGain = context.createGain();
            const panner = context.createStereoPanner(); // NEW: Pan for delay
            const lpf = context.createBiquadFilter(); // NEW: LPF for delay
            lpf.type = 'lowpass';
            lpf.frequency.value = 20000;
            const hpf = context.createBiquadFilter(); // NEW: HPF for delay
            hpf.type = 'highpass';
            hpf.frequency.value = 0;


            input.connect(delay);
            delay.connect(hpf); // HPF in feedback path
            hpf.connect(lpf); // LPF in feedback path
            lpf.connect(feedbackGain);
            feedbackGain.connect(delay); // Feedback loop

            delay.connect(panner); // Panner before output
            panner.connect(output); // Delay output (wet) goes to this output

            return { input, output, delay, feedbackGain, panner, lpf, hpf };
        }

        function updateDelayControls(delayId) {
            const delayInstance = activeDelayInstances.find(d => d.id === delayId);
            if (!delayInstance || !delayInstance.audioNodes) return;

            const timeBeats = parseFloat(delayInstance.dom.delayTimeSlider.value);
            const feedback = parseFloat(delayInstance.dom.delayFeedbackSlider.value);
            const mix = parseFloat(delayInstance.dom.delayMixSlider.value);
            const pan = parseFloat(delayInstance.dom.delayPanSlider.value); // NEW
            const lpfFreq = parseFloat(delayInstance.dom.delayLowpassSlider.value); // NEW
            const hpfFreq = parseFloat(delayInstance.dom.delayHighpassSlider.value); // NEW

            delayInstance.audioNodes.delay.delayTime.value = timeBeats * globalBeatDuration;
            delayInstance.audioNodes.feedbackGain.gain.value = feedback;
            delayInstance.audioNodes.panner.pan.value = pan; // NEW
            delayInstance.audioNodes.lpf.frequency.value = lpfFreq; // NEW
            delayInstance.audioNodes.hpf.frequency.value = hpfFreq; // NEW
            
            delayInstance.wetGainNode.gain.value = mix; // Controls how much of the wet signal reaches the master

            delayInstance.dom.delayTimeValueSpan.textContent = `${timeBeats} beats`;
            delayInstance.dom.delayFeedbackValueSpan.textContent = `${(feedback * 100).toFixed(0)}%`;
            delayInstance.dom.delayMixValueSpan.textContent = `${(mix * 100).toFixed(0)}%`;
            delayInstance.dom.delayPanValueSpan.textContent = `${(pan * 100).toFixed(0)}`; // NEW
            delayInstance.dom.delayLowpassValueSpan.textContent = `${lpfFreq} Hz`; // NEW
            delayInstance.dom.delayHighpassValueSpan.textContent = `${hpfFreq} Hz`; // NEW
        }

        function toggleDelay(delayId) {
            const delayInstance = activeDelayInstances.find(d => d.id === delayId);
            if (!delayInstance || !delayInstance.onOffGainNode) return;

            delayInstance.isDelayOn = !delayInstance.isDelayOn;
            delayInstance.onOffGainNode.gain.value = delayInstance.isDelayOn ? 1 : 0;
            delayInstance.dom.delayOnOffButton.textContent = delayInstance.isDelayOn ? 'Delay On' : 'Delay Off';
            delayInstance.dom.delayOnOffButton.style.backgroundColor = delayInstance.isDelayOn ? varCSS('--primary-color') : varCSS('--input-bg');
        }

        function addDelayInstance(savedSettings = {}) {
            initAudioContext();
            delayIdCounter++;
            const id = delayIdCounter;

            const delayDiv = document.createElement('div');
            delayDiv.className = 'dynamic-delay-instance';
            delayDiv.id = `delay-instance-${id}`;
            dynamicDelayContainer.appendChild(delayDiv);

            delayDiv.innerHTML = `
                <div class="global-section-header">Delay Instance ${id}</div>
                <button class="remove-button" id="removeDelay-${id}">Remove</button>
                <div class="input-group" style="width: 250px;">
                    <button id="delayOnOffButton-${id}" style="background-color: var(--input-bg);">Delay Off</button>
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayTime-${id}">Time (beats):</label>
                        <span id="delayTimeValue-${id}">0.5 beats</span>
                    </div>
                    <input type="range" id="delayTime-${id}" min="0.125" max="4" step="0.125" value="0.5">
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayFeedback-${id}">Feedback:</label>
                        <span id="delayFeedbackValue-${id}">50%</span>
                    </div>
                    <input type="range" id="delayFeedback-${id}" min="0" max="0.95" step="0.01" value="0.5">
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayMix-${id}">Mix (Wet):</label>
                        <span id="delayMixValue-${id}">0%</span>
                    </div>
                    <input type="range" id="delayMix-${id}" min="0" max="1" step="0.01" value="0.0">
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayPan-${id}">Pan:</label>
                        <span id="delayPanValue-${id}">0</span>
                    </div>
                    <input type="range" id="delayPan-${id}" min="-1" max="1" step="0.01" value="0">
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayLowpass-${id}">Lowpass (Hz):</label>
                        <span id="delayLowpassValue-${id}">20000 Hz</span>
                    </div>
                    <input type="range" id="delayLowpass-${id}" min="1000" max="20000" step="100" value="20000">
                </div>
                <div class="input-group" style="width: 250px;">
                    <div class="slider-label">
                        <label for="delayHighpass-${id}">Highpass (Hz):</label>
                        <span id="delayHighpassValue-${id}">0 Hz</span>
                    </div>
                    <input type="range" id="delayHighpass-${id}" min="0" max="1000" step="10" value="0">
                </div>
            `;

            const audioNodes = createDelayEffect(audioContext);
            const onOffGainNode = audioContext.createGain(); // Gate for turning on/off
            const wetGainNode = audioContext.createGain(); // Controls mix amount of wet signal
            
            masterInputMixer.connect(onOffGainNode); // Input to gate
            onOffGainNode.connect(audioNodes.input); // Gate to delay input
            audioNodes.output.connect(wetGainNode); // Delay wet output to wet mix gain
            wetGainNode.connect(masterGainNode); // Wet mix gain to master

            const delayInstance = {
                id: id,
                dom: {
                    delayDiv: delayDiv,
                    removeButton: delayDiv.querySelector(`#removeDelay-${id}`),
                    delayOnOffButton: delayDiv.querySelector(`#delayOnOffButton-${id}`),
                    delayTimeSlider: delayDiv.querySelector(`#delayTime-${id}`),
                    delayTimeValueSpan: delayDiv.querySelector(`#delayTimeValue-${id}`),
                    delayFeedbackSlider: delayDiv.querySelector(`#delayFeedback-${id}`),
                    delayFeedbackValueSpan: delayDiv.querySelector(`#delayFeedbackValue-${id}`),
                    delayMixSlider: delayDiv.querySelector(`#delayMix-${id}`),
                    delayMixValueSpan: delayDiv.querySelector(`#delayMixValue-${id}`),
                    delayPanSlider: delayDiv.querySelector(`#delayPan-${id}`), // NEW
                    delayPanValueSpan: delayDiv.querySelector(`#delayPanValue-${id}`), // NEW
                    delayLowpassSlider: delayDiv.querySelector(`#delayLowpass-${id}`), // NEW
                    delayLowpassValueSpan: delayDiv.querySelector(`#delayLowpassValue-${id}`), // NEW
                    delayHighpassSlider: delayDiv.querySelector(`#delayHighpass-${id}`), // NEW
                    delayHighpassValueSpan: delayDiv.querySelector(`#delayHighpassValue-${id}`), // NEW
                },
                audioNodes: audioNodes,
                onOffGainNode: onOffGainNode,
                wetGainNode: wetGainNode,
                isDelayOn: savedSettings.isDelayOn !== undefined ? savedSettings.isDelayOn : false,
            };

            activeDelayInstances.push(delayInstance);

            // Apply saved settings or defaults
            delayInstance.dom.delayTimeSlider.value = savedSettings.delayTime !== undefined ? savedSettings.delayTime : 0.5;
            delayInstance.dom.delayFeedbackSlider.value = savedSettings.delayFeedback !== undefined ? savedSettings.delayFeedback : 0.5;
            delayInstance.dom.delayMixSlider.value = savedSettings.delayMix !== undefined ? savedSettings.delayMix : 0.0;
            delayInstance.dom.delayPanSlider.value = savedSettings.delayPan !== undefined ? savedSettings.delayPan : 0.0;
            delayInstance.dom.delayLowpassSlider.value = savedSettings.delayLowpass !== undefined ? savedSettings.delayLowpass : 20000;
            delayInstance.dom.delayHighpassSlider.value = savedSettings.delayHighpass !== undefined ? savedSettings.delayHighpass : 0;
            
            // Set initial on/off state
            delayInstance.onOffGainNode.gain.value = delayInstance.isDelayOn ? 1 : 0;
            delayInstance.dom.delayOnOffButton.textContent = delayInstance.isDelayOn ? 'Delay On' : 'Delay Off';
            delayInstance.dom.delayOnOffButton.style.backgroundColor = delayInstance.isDelayOn ? varCSS('--primary-color') : varCSS('--input-bg');


            updateDelayControls(id); // Apply settings to audio nodes and update spans

            // Add Event Listeners
            delayInstance.dom.removeButton.addEventListener('click', () => removeDelayInstance(id));
            delayInstance.dom.delayOnOffButton.addEventListener('click', () => toggleDelay(id));
            delayInstance.dom.delayTimeSlider.addEventListener('input', () => updateDelayControls(id));
            delayInstance.dom.delayFeedbackSlider.addEventListener('input', () => updateDelayControls(id));
            delayInstance.dom.delayMixSlider.addEventListener('input', () => updateDelayControls(id));
            delayInstance.dom.delayPanSlider.addEventListener('input', () => updateDelayControls(id));
            delayInstance.dom.delayLowpassSlider.addEventListener('input', () => updateDelayControls(id));
            delayInstance.dom.delayHighpassSlider.addEventListener('input', () => updateDelayControls(id));

            return delayInstance;
        }

        function removeDelayInstance(id) {
            const index = activeDelayInstances.findIndex(d => d.id === id);
            if (index !== -1) {
                const delayInstance = activeDelayInstances[index];
                // Disconnect audio nodes
                delayInstance.onOffGainNode.disconnect();
                delayInstance.audioNodes.input.disconnect();
                delayInstance.audioNodes.output.disconnect();
                delayInstance.wetGainNode.disconnect();
                
                // Remove DOM elements
                delayInstance.dom.delayDiv.remove();
                activeDelayInstances.splice(index, 1);
                console.log(`Delay instance ${id} removed.`);
            }
        }


        function toggleHumanizer() {
            isHumanizerOn = !isHumanizerOn;
            humanizerOnOffButton.textContent = isHumanizerOn ? 'Humanizer On' : 'Humanizer Off';
            humanizerOnOffButton.style.backgroundColor = isHumanizerOn ? varCSS('--primary-color') : varCSS('--input-bg');
        }

        function updateHumanizerControls() {
            humanizeTimingValueSpan.textContent = `${humanizeTimingSlider.value}ms`;
            humanizeVelocityValueSpan.textContent = `${humanizeVelocitySlider.value}%`;
            humanizePanValueSpan.textContent = `${humanizePanSlider.value}%`;
            humanizerOnOffButton.textContent = isHumanizerOn ? 'Humanizer On' : 'Humanizer Off';
            humanizerOnOffButton.style.backgroundColor = isHumanizerOn ? varCSS('--primary-color') : varCSS('--input-bg');
        }


        // --- Web MIDI API ---
        async function initWebMidi() {
            if (!navigator.requestMIDIAccess) {
                console.warn("Web MIDI API is not supported in this browser.");
                globalMidiOutDeviceSelect.innerHTML = '<option>MIDI not supported</option>';
                globalMidiOutDeviceSelect.disabled = true;
                return null;
            }
            if (midiAccess) return midiAccess;

            try {
                midiAccess = await navigator.requestMIDIAccess({ sysex: false });
                console.log("MIDI Access granted.");
                populateGlobalMidiDevices(midiAccess);
                midiAccess.onstatechange = (event) => populateGlobalMidiDevices(event.currentTarget);
                return midiAccess;
            } catch (error) {
                console.error("Failed to get MIDI access:", error);
                globalMidiOutDeviceSelect.innerHTML = '<option>MIDI access denied</option>';
                globalMidiOutDeviceSelect.disabled = true;
                return null;
            }
        }

        function populateGlobalMidiDevices(midi) {
            globalMidiOutDeviceSelect.innerHTML = '';
            const outputs = midi.outputs.values();
            let hasDevices = false;
            let currentSelectedId = globalMidiOutDeviceSelect.value;

            for (let output of outputs) {
                const option = document.createElement('option');
                option.value = output.id;
                option.textContent = output.name;
                globalMidiOutDeviceSelect.appendChild(option);
                hasDevices = true;
            }

            if (!hasDevices) {
                globalMidiOutDeviceSelect.innerHTML = '<option>No MIDI Output Devices</option>';
                globalMidiOutDeviceSelect.disabled = true;
                selectedGlobalMidiOutput = null;
            } else {
                globalMidiOutDeviceSelect.disabled = false;
                if (currentSelectedId && midi.outputs.has(currentSelectedId)) {
                    globalMidiOutDeviceSelect.value = currentSelectedId;
                } else {
                    globalMidiOutDeviceSelect.selectedIndex = 0;
                }
                selectedGlobalMidiOutput = midi.outputs.get(globalMidiOutDeviceSelect.value);
            }
        }

        function handleGlobalMidiDeviceChange() {
            if (midiAccess) {
                selectedGlobalMidiOutput = midiAccess.outputs.get(globalMidiOutDeviceSelect.value);
                console.log("Global MIDI output selected:", selectedGlobalMidiOutput ? selectedGlobalMidiOutput.name : "None");
            }
        }

        // --- Global Waveform Drawing ---
        function drawGlobalWaveform() {
            globalWaveformAnimationId = requestAnimationFrame(drawGlobalWaveform);

            if (!globalAnalyser || !globalWaveformDataArray || !globalWaveformCtx) return;

            globalAnalyser.getByteTimeDomainData(globalWaveformDataArray);

            globalWaveformCtx.clearRect(0, 0, globalWaveformCanvas.width, globalWaveformCanvas.height);
            globalWaveformCtx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--global-waveform-bg');
            globalWaveformCtx.fillRect(0, 0, globalWaveformCanvas.width, globalWaveformCanvas.height);

            globalWaveformCtx.lineWidth = 2;
            globalWaveformCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--waveform-color-global');
            globalWaveformCtx.beginPath();

            const sliceWidth = globalWaveformCanvas.width * 1.0 / globalWaveformBufferLength;
            let x = 0;

            for (let i = 0; i < globalWaveformDataArray.length; i++) {
                const v = globalWaveformDataArray[i] / 128.0;
                const y = v * globalWaveformCanvas.height / 2;

                if (i === 0) {
                    globalWaveformCtx.moveTo(x, y);
                } else {
                    globalWaveformCtx.lineTo(x, y);
                }
                x += sliceWidth;
            }

            globalWaveformCtx.lineTo(globalWaveformCanvas.width, globalWaveformCanvas.height / 2);
            globalWaveformCtx.stroke();
        }

        function startGlobalWaveformDrawing() {
            if (!globalWaveformAnimationId) {
                drawGlobalWaveform();
            }
        }
        function stopGlobalWaveformDrawing() {
            if (globalWaveformAnimationId) {
                cancelAnimationFrame(globalWaveformAnimationId);
                globalWaveformAnimationId = null;
            }
        }


        // --- Sequencer Class ---
        class Sequencer {
            constructor(id, parentElement, savedSettings = {}) {
                this.id = id;
                this.parentElement = parentElement;
                this.canvasWidth = 800;
                this.canvasHeight = 200;
                this.lineY = this.canvasHeight / 2;
                this.circleRadius = 15;
                this.circles = []; // Stores { x, played, velocity, pan }
                this.verticalLineX = 0;
                this.audioBuffer = null;
                this.waveformData = null;
                this.audioPlayingSource = null;
                this.isMuted = savedSettings.isMuted !== undefined ? savedSettings.isMuted : false;
                this.wavFileName = savedSettings.wavFileName || '';
                this.phase = savedSettings.phase !== undefined ? savedSettings.phase : 0; // New phase control
                this.editMode = savedSettings.editMode || 'add'; // NEW: default edit mode
                this.presetRhythm = savedSettings.presetRhythm || 'off'; // NEW: preset rhythm setting

                // Dragging state for circles
                this.isDragging = false;
                this.dragStartX = 0;
                this.circleStartX = 0;

                // Per-sequencer audio nodes
                this.sequencerGainNode = audioContext.createGain();
                this.sequencerGainNode.gain.value = savedSettings.volume !== undefined ? savedSettings.volume : 0.75;
                this.sequencerPannerNode = audioContext.createStereoPanner();
                this.sequencerPannerNode.pan.value = savedSettings.pan !== undefined ? savedSettings.pan : 0;

                // Connect sequencer output to masterInputMixer
                this.sequencerGainNode.connect(this.sequencerPannerNode);
                this.sequencerPannerNode.connect(masterInputMixer);


                this.createDOM();
                this.addEventListeners();
                this.applySavedSettings(savedSettings);
                this.draw(); // Initial draw
            }

            createDOM() {
                this.sequencerDiv = document.createElement('div');
                this.sequencerDiv.className = 'sequencer';
                this.sequencerDiv.id = `sequencer-${this.id}`;

                this.sequencerDiv.innerHTML = `

                    <canvas id="rhythmCanvas-${this.id}" width="${this.canvasWidth}" height="${this.canvasHeight}"></canvas>

                    <div class="controls-left">
                        <div class="sequencer-playback-controls">
                            <div class="slider-label">
                                <label for="sequencerVolume-${this.id}">Volume:</label>
                                <span id="sequencerVolumeValue-${this.id}">${(this.sequencerGainNode.gain.value * 100).toFixed(0)}%</span>
                            </div>
                            <input type="range" id="sequencerVolume-${this.id}" min="0" max="1" step="0.01" value="${this.sequencerGainNode.gain.value}">
                            <div class="slider-label">
                                <label for="sequencerPan-${this.id}">Pan:</label>
                                <span id="sequencerPanValue-${this.id}">${(this.sequencerPannerNode.pan.value * 100).toFixed(0)}</span>
                            </div>
                            <input type="range" id="sequencerPan-${this.id}" min="-1" max="1" step="0.01" value="${this.sequencerPannerNode.pan.value}">
                            <div class="input-group" style="display: flex; gap: 5px;">
                                <button class="play-stop-button" id="playStopButton-${this.id}" style="flex: 1;">${this.isMuted ? 'Muted' : 'Unmuted'}</button>
                                <button class="solo-button" id="soloButton-${this.id}" style="flex: 1;">Play/Stop Seq</button>
                            </div>
                        </div>
                    </div>

                    
                    <div class="controls-right">
                        <div class="input-group">
                            <label for="presetRhythms-${this.id}">Preset Rhythms:</label>
                            <select id="presetRhythms-${this.id}">
                                <option value="off">- Off -</option>
                                <option value="4 on the floor">4 on the floor</option>
                                <option value="Hip-hop">Hip-hop</option>
                                <option value="Funk">Funk</option>
                                <option value="Swing">Swing</option>
                                <option value="Double Beat">Double Beat</option>
                                <option value="Reggae">Reggae</option>
                                <option value="Blues">Blues</option>
                                <option value="Jazz">Jazz</option>
                                <option value="D-Beat">D-Beat</option>
                                <option value="Samba">Samba</option>
                                <option value="Bossa Nova">Bossa Nova</option>
                                <option value="Forró">Forró</option>
                                <option value="Frevo">Frevo</option>
                                <option value="Maracatu">Maracatu</option>
                                <option value="Techno">Techno</option>
                                <option value="House">House</option>
                                <option value="Dubstep">Dubstep</option>
                                <option value="Trap">Trap</option>
                                <option value="Trance">Trance</option>
                                <option value="Drum and Bass">Drum and Bass</option>
                                <option value="Gospel">Gospel</option>
                                <option value="Slow Rock">Slow Rock</option>
                                <option value="Pop">Pop</option>
                                <option value="Metal">Metal</option>
                                <option value="Latin Jazz">Latin Jazz</option>
                                <option value="Afrobeat">Afrobeat</option>
                                <option value="Cumbia">Cumbia</option>
                                <option value="Merengue">Merengue</option>
                                <option value="Salsa">Salsa</option>

                            </select>
                        </div>
                        <div class="input-group">
                            <label for="division-${this.id}">Division (e.g., 1/4, 0.5):</label>
                            <input type="text" id="division-${this.id}" value="1/4">
                            <button id="applyDivision-${this.id}">Apply Division</button>
                        </div>
                        <div class="input-group">
                            <div class="slider-label">
                                <label for="phase-${this.id}">Phase (%):</label>
                                <span id="phaseValue-${this.id}">${this.phase}%</span>
                            </div>
                            <input type="range" id="phase-${this.id}" min="0" max="100" step="1" value="${this.phase}">
                        </div>
                        <div class="input-group">
                            <label for="editMode-${this.id}">Mode:</label>
                            <select id="editMode-${this.id}">
                                <option value="add">Add (A)</option>
                                <option value="edit">Edit (S)</option>
                                <option value="delete">Delete (D)</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <button id="generateSingleBeat-${this.id}">Create Random Beat</button>
                        </div>
                    </div>

                    <div class="controls-right">
                        <div class="input-group">
                            <label for="wavFile-${this.id}">WAV File: <span id="wavFileName-${this.id}" style="font-style: italic; font-size: 0.8em;">${this.wavFileName || 'No file selected'}</span></label>
                            <input type="file" id="wavFile-${this.id}" class="file-upload-hidden" accept=".wav">
                            <label for="wavFile-${this.id}" class="file-upload-label">Choose WAV</label>
                        </div>
                        <div class="input-group">
                            <label for="preloadedSounds-${this.id}">Preloaded Sounds:</label>
                            <select id="preloadedSounds-${this.id}"></select>
                        </div>
                        <div class="input-group">
                            <label for="midiOutChannel-${this.id}">MIDI Out Channel (1-16):</label>
                            <input type="number" id="midiOutChannel-${this.id}" min="1" max="16" value="1">
                        </div>
                        <div class="input-group">
                            <label for="midiOutNote-${this.id}">MIDI Out Note (0-127):</label>
                            <input type="number" id="midiOutNote-${this.id}" min="0" max="127" value="${60 + this.id - 1}">
                        </div>
                    </div>

                    <button class="remove-button" id="removeSequencer-${this.id}">Remove</button>
                `;
                this.parentElement.appendChild(this.sequencerDiv);

                // Get references to DOM elements
                this.canvas = this.sequencerDiv.querySelector(`#rhythmCanvas-${this.id}`);
                this.ctx = this.canvas.getContext('2d');
                this.wavFileInput = this.sequencerDiv.querySelector(`#wavFile-${this.id}`);
                this.wavFileNameSpan = this.sequencerDiv.querySelector(`#wavFileName-${this.id}`);
                this.preloadedSoundsSelect = this.sequencerDiv.querySelector(`#preloadedSounds-${this.id}`);
                this.sequencerVolumeSlider = this.sequencerDiv.querySelector(`#sequencerVolume-${this.id}`);
                this.sequencerVolumeValueSpan = this.sequencerDiv.querySelector(`#sequencerVolumeValue-${this.id}`);
                this.sequencerPanSlider = this.sequencerDiv.querySelector(`#sequencerPan-${this.id}`);
                this.sequencerPanValueSpan = this.sequencerDiv.querySelector(`#sequencerPanValue-${this.id}`);
                this.divisionInput = this.sequencerDiv.querySelector(`#division-${this.id}`);
                this.applyDivisionButton = this.sequencerDiv.querySelector(`#applyDivision-${this.id}`);
                this.midiOutChannelInput = this.sequencerDiv.querySelector(`#midiOutChannel-${this.id}`);
                this.midiOutNoteInput = this.sequencerDiv.querySelector(`#midiOutNote-${this.id}`);
                this.removeButton = this.sequencerDiv.querySelector(`#removeSequencer-${this.id}`);
                this.playStopButton = this.sequencerDiv.querySelector(`#playStopButton-${this.id}`);
                this.soloButton = this.sequencerDiv.querySelector(`#soloButton-${this.id}`);
                this.phaseInput = this.sequencerDiv.querySelector(`#phase-${this.id}`);
                this.phaseValueSpan = this.sequencerDiv.querySelector(`#phaseValue-${this.id}`);
                this.editModeSelect = this.sequencerDiv.querySelector(`#editMode-${this.id}`);
                this.generateSingleBeatButton = this.sequencerDiv.querySelector(`#generateSingleBeat-${this.id}`);
                this.presetRhythmsSelect = this.sequencerDiv.querySelector(`#presetRhythms-${this.id}`); // NEW

                this.populatePreloadedSounds();

                if (this.isMuted) {
                    this.playStopButton.classList.add('stop');
                }
                this.editModeSelect.value = this.editMode;
                this.presetRhythmsSelect.value = this.presetRhythm;
            }

            addEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleCanvasMouseDown.bind(this));
                this.wavFileInput.addEventListener('change', this.loadWavFile.bind(this)); 
                this.preloadedSoundsSelect.addEventListener('change', this.handlePreloadedSoundChange.bind(this));
                this.sequencerVolumeSlider.addEventListener('input', this.handleVolumeChange.bind(this));
                this.sequencerPanSlider.addEventListener('input', this.handlePanChange.bind(this));
                this.divisionInput.addEventListener('change', this.applyDivisionSetting.bind(this));
                this.applyDivisionButton.addEventListener('click', this.applyDivisionSetting.bind(this));
                this.midiOutChannelInput.addEventListener('change', () => console.log(`Sequencer ${this.id}: MIDI Channel changed to ${this.midiOutChannelInput.value}`));
                this.midiOutNoteInput.addEventListener('change', () => console.log(`Sequencer ${this.id}: MIDI Note changed to ${this.midiOutNoteInput.value}`));
                this.removeButton.addEventListener('click', this.remove.bind(this));
                this.playStopButton.addEventListener('click', this.toggleMute.bind(this));
                this.soloButton.addEventListener('click', this.toggleSequencerPlayback.bind(this)); // Changed from toggleSolo
                this.phaseInput.addEventListener('input', this.handlePhaseChange.bind(this));
                this.editModeSelect.addEventListener('change', (e) => {
                    this.editMode = e.target.value;
                    if (this.editMode === 'add' || this.editMode === 'delete') {
                        this.deselectCircle(); // Close controls if not in edit mode
                    }
                    console.log(`Sequencer ${this.id}: Edit mode changed to ${this.editMode}`);
                    this.draw(); // Redraw to update potential highlights/cursors
                });
                this.generateSingleBeatButton.addEventListener('click', this.generateRandomBeat.bind(this));
                this.presetRhythmsSelect.addEventListener('change', this.applyPresetRhythm.bind(this)); // NEW
            }

            handleCanvasMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                const clickX = event.clientX - rect.left;

                // Adjust clickX for visual phase to find the correct circle
                let unphasedClickX = clickX - (this.phase / 100) * this.canvasWidth;
                unphasedClickX %= this.canvasWidth;
                if (unphasedClickX < 0) unphasedClickX += this.canvasWidth;

                const clickedCircleIndex = this.circles.findIndex(circle =>
                    Math.abs(unphasedClickX - circle.x) < this.circleRadius
                );

                if (this.editMode === 'add') {
                    if (clickedCircleIndex === -1) {
                        const newCircle = { x: unphasedClickX, played: false, velocity: 100, pan: 0 };
                        this.circles.push(newCircle);
                        this.circles.sort((a, b) => a.x - b.x);
                        // Do NOT selectCircle or open controls in 'add' mode
                    }
                    // If clicked on existing in add mode, do nothing specific to selection
                } else if (this.editMode === 'edit') {
                    if (clickedCircleIndex !== -1) {
                        this.selectCircle(clickedCircleIndex);
                        this.isDragging = true;
                        this.dragStartX = event.clientX;
                        this.circleStartX = this.circles[clickedCircleIndex].x;
                        
                        // Add global mousemove/mouseup listeners for dragging
                        window.addEventListener('mousemove', this.handleCanvasMouseMove);
                        window.addEventListener('mouseup', this.handleCanvasMouseUp);
                    } else {
                        this.deselectCircle(); // Clicked empty space in edit mode, deselect
                    }
                } else if (this.editMode === 'delete') {
                    if (clickedCircleIndex !== -1) {
                        this.circles.splice(clickedCircleIndex, 1);
                        this.deselectCircle(); // Always deselect if a circle is deleted
                    }
                }
                this.draw();
            }
            
            // Use arrow functions or bind in constructor to maintain 'this' context for global listeners
            handleCanvasMouseMove = (event) => {
                if (this.isDragging && selectedCircle.sequencer === this && selectedCircle.circleIndex !== -1) {
                    const dragDeltaX = event.clientX - this.dragStartX;
                    let newX = this.circleStartX + dragDeltaX;

                    // Constrain the circle's X position within the canvas boundaries (0 to canvasWidth)
                    newX = Math.max(0, Math.min(this.canvasWidth, newX));

                    this.circles[selectedCircle.circleIndex].x = newX;
                    
                    // Update the selected circle controls immediately during drag (NEW)
                    circleXPositionInput.value = newX.toFixed(0);
                    circleXRatioInput.value = (newX / this.canvasWidth).toFixed(3);

                    this.draw();
                }
            }

            handleCanvasMouseUp = () => {
                this.isDragging = false;
                window.removeEventListener('mousemove', this.handleCanvasMouseMove);
                window.removeEventListener('mouseup', this.handleCanvasMouseUp);
                // Re-sort after dragging to maintain order if necessary
                this.circles.sort((a, b) => a.x - b.x);
                this.draw();
            }

            populatePreloadedSounds() {
                this.preloadedSoundsSelect.innerHTML = '<option value="">- Select -</option>';
                preloadedSounds.forEach((sound, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = sound.name;
                    this.preloadedSoundsSelect.appendChild(option);
                });
            }

            handlePreloadedSoundChange(event) {
                const selectedIndex = event.target.value;
                if (selectedIndex !== "") {
                    const sound = preloadedSounds[parseInt(selectedIndex)];
                    this.loadWavFile(sound.path);
                    this.wavFileName = sound.path.split('/').pop();
                    this.wavFileInput.value = ''; // Clear file input
                    this.wavFileNameSpan.textContent = this.wavFileName;
                }
            }

            handleVolumeChange() {
                this.sequencerGainNode.gain.value = parseFloat(this.sequencerVolumeSlider.value);
                this.sequencerVolumeValueSpan.textContent = `${(this.sequencerGainNode.gain.value * 100).toFixed(0)}%`;
            }

            handlePanChange() {
                this.sequencerPannerNode.pan.value = parseFloat(this.sequencerPanSlider.value);
                this.sequencerPanValueSpan.textContent = `${(this.sequencerPannerNode.pan.value * 100).toFixed(0)}`;
            }

            handlePhaseChange() {
                this.phase = parseInt(this.phaseInput.value);
                this.phaseValueSpan.textContent = `${this.phase}%`;
                this.draw(); // Redraw to show phased circles
            }

            // Renamed from toggleSolo to toggleSequencerPlayback (NEW)
            toggleSequencerPlayback() {
                if (globalSoloedId === this.id) {
                    // This sequencer is currently soloed, so stop soloing it
                    globalSoloedId = null;
                    if (isPlayingGlobal) {
                        toggleGlobalPlayStop(); // Stop global playback if it was initiated by solo
                    }

                    // Restore previous mute state for all sequencers
                    activeSequencers.forEach(seq => {
                        seq.isMuted = preSoloMuteStates.get(seq.id) || false;
                        if (seq.isMuted) {
                            seq.playStopButton.classList.add('stop');
                            seq.playStopButton.textContent = 'Muted';
                        } else {
                            seq.playStopButton.classList.remove('stop');
                            seq.playStopButton.textContent = 'Unmuted';
                        }
                        seq.soloButton.classList.remove('active'); // Remove active class from all solo buttons
                    });
                    preSoloMuteStates.clear();
                    console.log(`Sequencer ${this.id} unsoloed.`);
                } else {
                    // Soloing this sequencer
                    if (globalSoloedId !== null) { // If another sequencer was soloed, unsolo it first
                        const prevSoloed = activeSequencers.find(seq => seq.id === globalSoloedId);
                        if (prevSoloed) prevSoloed.toggleSequencerPlayback(); // Recursively call to unsolo previous
                    }

                    // Store current mute states for all sequencers before changing them
                    activeSequencers.forEach(seq => {
                        preSoloMuteStates.set(seq.id, seq.isMuted);
                    });

                    globalSoloedId = this.id; // Set this sequencer as soloed

                    // Stop global playback if it's running before starting the solo one
                    if (isPlayingGlobal) {
                        toggleGlobalPlayStop();
                    }

                    // Ensure this sequencer is unmuted and others are muted
                    activeSequencers.forEach(seq => {
                        if (seq.id === this.id) {
                            seq.isMuted = false; // Ensure soloed track is unmuted
                            seq.playStopButton.classList.remove('stop');
                            seq.playStopButton.textContent = 'Unmuted';
                            seq.soloButton.classList.add('active'); // Add active class to this solo button
                        } else {
                            seq.isMuted = true; // Mute other tracks
                            seq.playStopButton.classList.add('stop');
                            seq.playStopButton.textContent = 'Muted';
                            seq.soloButton.classList.remove('active'); // Remove active class from other solo buttons
                        }
                    });

                    // Start global playback (which will now only play this sequencer)
                    toggleGlobalPlayStop();
                    console.log(`Sequencer ${this.id} soloed and started playback.`);
                }
            }


            applySavedSettings(settings) {
                if (settings.circles) {
                    this.circles = settings.circles.map(c => ({
                        x: c.x,
                        played: false,
                        velocity: c.velocity !== undefined ? c.velocity : 100,
                        pan: c.pan !== undefined ? c.pan : 0
                    }));
                    this.circles.sort((a, b) => a.x - b.x);
                }
                if (settings.division) {
                    this.divisionInput.value = settings.division;
                    this.applyDivisionSetting();
                }
                if (settings.channel) {
                    this.midiOutChannelInput.value = settings.channel;
                }
                if (settings.note) {
                    this.midiOutNoteInput.value = settings.note;
                }
                if (settings.wavFileName) {
                    this.wavFileName = settings.wavFileName;
                    this.wavFileNameSpan.textContent = settings.wavFileName;
                    const preloadedIndex = preloadedSounds.findIndex(s => s.path.endsWith(settings.wavFileName));
                    if (preloadedIndex !== -1) {
                        this.preloadedSoundsSelect.value = preloadedIndex.toString();
                        this.loadWavFile(preloadedSounds[preloadedIndex].path);
                    } else if (settings.wavFileName !== 'No file selected') { // Handle previously loaded custom files
                         // If it's not a preloaded sound, we can't load it automatically by path
                         console.warn(`Sequencer ${this.id}: Custom WAV file '${settings.wavFileName}' cannot be reloaded automatically. Please re-upload.`);
                    }
                }
                if (settings.volume !== undefined) {
                    this.sequencerVolumeSlider.value = settings.volume;
                    this.handleVolumeChange(); // Update node and span
                }
                if (settings.pan !== undefined) {
                    this.sequencerPanSlider.value = settings.pan;
                    this.handlePanChange(); // Update node and span
                }
                if (settings.phase !== undefined) { // New phase setting
                    this.phase = settings.phase;
                    this.phaseInput.value = settings.phase;
                    this.phaseValueSpan.textContent = `${settings.phase}%`;
                }
                if (settings.editMode !== undefined) { // New edit mode setting
                    this.editMode = settings.editMode;
                    this.editModeSelect.value = settings.editMode;
                }
                if (settings.presetRhythm !== undefined) { // NEW preset rhythm setting
                    this.presetRhythm = settings.presetRhythm;
                    this.presetRhythmsSelect.value = settings.presetRhythm;
                    if (settings.presetRhythm !== 'off') {
                        this.applyPresetRhythm(null, settings.presetRhythm); // Apply the rhythm from saved settings
                    }
                }


                this.isMuted = settings.isMuted !== undefined ? settings.isMuted : false;
                if (this.isMuted) {
                    this.playStopButton.classList.add('stop');
                    this.playStopButton.textContent = 'Muted';
                } else {
                    this.playStopButton.classList.remove('stop');
                    this.playStopButton.textContent = 'Unmuted';
                }

                // If this sequencer was soloed in saved settings, apply solo state (NEW)
                // We only set the active class here. The actual muting/unmuting of others happens
                // in applyLoadedSettings after all sequencers are created.
                if (settings.isSoloed && settings.isSoloed === true) {
                    this.soloButton.classList.add('active');
                } else {
                     this.soloButton.classList.remove('active');
                }
            }
            
            sendMidiNote(note, velocity, pan, duration, startTimeOffset = 0) {
                if (!selectedGlobalMidiOutput || !audioContext || this.isMuted) return;

                const channel = parseInt(this.midiOutChannelInput.value) - 1;
                if (isNaN(channel) || channel < 0 || channel > 15) return;
                if (isNaN(note) || note < 0 || note > 127) return;

                const velocityClamped = Math.min(127, Math.max(0, velocity));

                // Pan (MIDI Control Change Message: 0xBN, Controller Number (10 for Pan), Value (0-127))
                const midiPanValue = Math.round((pan + 1) * 63.5); // Convert -1 to 1 to 0 to 127
                
                const midiTimestamp = audioContext.currentTime * 1000 + startTimeOffset * 1000; // Apply offset in milliseconds

                // Note On
                selectedGlobalMidiOutput.send([0x90 + channel, note, velocityClamped], midiTimestamp);

                // Pan CC (send simultaneously with Note On)
                selectedGlobalMidiOutput.send([0xB0 + channel, 10, midiPanValue], midiTimestamp);

                // Note Off
                selectedGlobalMidiOutput.send([0x80 + channel, note, velocityClamped], midiTimestamp + (duration * 1000));
            }

            // --- Canvas Drawing ---
            draw() {
                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);

                this.ctx.strokeStyle = varCSS('--canvas-line');
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.lineY);
                this.ctx.lineTo(this.canvasWidth, this.lineY);
                this.ctx.stroke();

                const baseCircleFill = varCSS('--circle-fill').trim();
                const baseRgb = hexToRgb(baseCircleFill.startsWith('#') ? baseCircleFill : '#2196F3'); // Default Blue if CSS var is not hex

                this.circles.forEach((circle, index) => {
                    // --- Phase calculation for drawing ---
                    let phasedX = circle.x + (this.phase / 100) * this.canvasWidth;
                    phasedX %= this.canvasWidth;
                    if (phasedX < 0) phasedX += this.canvasWidth; // Ensure positive for negative shifts

                    // --- Velocity-based brightness ---
                    const velocityFactor = circle.velocity / 127; // 0 to 1
                    let r = baseRgb.r * (0.4 + 0.6 * velocityFactor); // Scale from 40% to 100% brightness
                    let g = baseRgb.g * (0.4 + 0.6 * velocityFactor);
                    let b = baseRgb.b * (0.4 + 0.6 * velocityFactor);

                    // --- Pan-based color blending (redder left, bluer right) ---
                    const panNormalized = circle.pan; // -1 to 1
                    if (panNormalized < 0) { // Shift towards red (more left)
                        const panIntensity = Math.abs(panNormalized); // 0 to 1
                        r = r * (1 - panIntensity) + 255 * panIntensity; // More red
                        g = g * (1 - panIntensity); // Less green
                        b = b * (1 - panIntensity); // Less blue
                    } else if (panNormalized > 0) { // Shift towards blue (more right)
                        const panIntensity = Math.abs(panNormalized); // 0 to 1
                        r = r * (1 - panIntensity); // Less red
                        g = g * (1 - panIntensity); // Less green
                        b = b * (1 - panIntensity) + 255 * panIntensity; // More blue
                    }
                    
                    r = Math.min(255, Math.max(0, Math.round(r)));
                    g = Math.min(255, Math.max(0, Math.round(g)));
                    b = Math.min(255, Math.max(0, Math.round(b)));

                    this.ctx.fillStyle = circle.played ? varCSS('--circle-hit-fill') : `rgb(${r},${g},${b})`;
                    this.ctx.strokeStyle = varCSS('--border-color');
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(phasedX, this.lineY, this.circleRadius, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // Highlight selected circle (also use phasedX)
                    if (selectedCircle.sequencer === this && selectedCircle.circleIndex === index) {
                        this.ctx.strokeStyle = varCSS('--accent-color');
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(phasedX, this.lineY, this.circleRadius + 3, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });

                this.ctx.strokeStyle = varCSS('--vertical-line');
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(this.verticalLineX, 0);
                this.ctx.lineTo(this.verticalLineX, this.canvasHeight);
                this.ctx.stroke();

                if (this.audioPlayingSource && this.waveformData && !this.isMuted) {
                    this.drawWaveformOverlay(this.verticalLineX, this.waveformData);
                }
            }

            drawWaveformOverlay(x, waveformBuffer) {
                if (!waveformBuffer || waveformBuffer.length === 0) return;

                this.ctx.strokeStyle = varCSS('--waveform-color-seq');
                this.ctx.lineWidth = 2;

                const waveformWidth = 100;
                const waveformHeight = this.canvasHeight * 0.6;

                this.ctx.beginPath();

                const bufferLength = waveformBuffer.length;
                const samplesToDraw = 150;
                const sampleStep = Math.floor(bufferLength / samplesToDraw);

                for (let i = 0; i < samplesToDraw; i++) {
                    const sampleIndex = Math.min(Math.floor(i * sampleStep), bufferLength - 1);
                    const sampleValue = waveformBuffer[sampleIndex];
                    const currentDrawX = x - (waveformWidth / 2) + (i / samplesToDraw) * waveformWidth;
                    const y = this.lineY + (sampleValue * (waveformHeight / 2));

                    if (i === 0) {
                        this.ctx.moveTo(currentDrawX, y);
                    } else {
                        this.ctx.lineTo(currentDrawX, y);
                    }
                }
                this.ctx.stroke();
            }

            // --- Individual Sequencer Tick (called by global loop) ---
            tick(deltaTime) {
                const loopDuration = globalBeatDuration * globalLoopBeats;

                // Update visual position of vertical line (unphased)
                this.verticalLineX = (globalLoopTime / loopDuration) * this.canvasWidth;

                // Only process hits if not muted and not globally soloed (unless it's THIS soloed sequencer)
                const canPlay = !this.isMuted && (globalSoloedId === null || globalSoloedId === this.id);

                if (canPlay) {
                    const previousGlobalLoopTimeRatio = (globalLoopTime - deltaTime) / loopDuration;
                    const currentGlobalLoopTimeRatio = globalLoopTime / loopDuration;

                    this.circles.forEach(circle => {
                        // Calculate the *phased* position of the circle for hit detection
                        let circleXRatio = circle.x / this.canvasWidth;
                        let phasedCircleXRatio = (circleXRatio + (this.phase / 100));
                        phasedCircleXRatio %= 1; // Wrap around
                        if (phasedCircleXRatio < 0) phasedCircleXRatio += 1; // Ensure positive

                        if (!circle.played) {
                            // Check if the global current time crossed the phased position of the circle
                            const crossedFromLeft = (previousGlobalLoopTimeRatio < phasedCircleXRatio && currentGlobalLoopTimeRatio >= phasedCircleXRatio);
                            // Handle wrap-around scenario for hit detection:
                            // If the line crossed 0/end AND the circle is at the very beginning/end of the loop after phasing
                            const wrappedAroundHit = (previousGlobalLoopTimeRatio > currentGlobalLoopTimeRatio && (phasedCircleXRatio >= previousGlobalLoopTimeRatio || phasedCircleXRatio < currentGlobalLoopTimeRatio));

                            if (crossedFromLeft || wrappedAroundHit) {
                                circle.played = true;

                                // Apply humanizer effects before playing
                                let effectiveStartTimeOffset = 0;
                                let effectiveVelocity = circle.velocity;
                                let effectivePan = circle.pan;

                                if (isHumanizerOn) { // Only apply if humanizer is ON
                                    const humanizeTimingAmount = parseFloat(humanizeTimingSlider.value) / 1000; // in seconds
                                    const humanizeVelocityAmount = parseFloat(humanizeVelocitySlider.value) / 100;
                                    const humanizePanAmount = parseFloat(humanizePanSlider.value) / 100;

                                    if (humanizeTimingAmount > 0) {
                                        effectiveStartTimeOffset = (Math.random() * 2 - 1) * humanizeTimingAmount; // -amount to +amount
                                    }
                                    if (humanizeVelocityAmount > 0) {
                                        const randomFactor = (Math.random() * 2 - 1) * humanizeVelocityAmount;
                                        effectiveVelocity = Math.round(effectiveVelocity * (1 + randomFactor));
                                        effectiveVelocity = Math.min(127, Math.max(0, effectiveVelocity));
                                    }
                                    if (humanizePanAmount > 0) {
                                        const randomFactor = (Math.random() * 2 - 1) * humanizePanAmount;
                                        effectivePan = Math.max(-1, Math.min(1, effectivePan + randomFactor));
                                    }
                                }
                                
                                if (this.audioBuffer) {
                                    this.playSound(effectiveVelocity, effectivePan, effectiveStartTimeOffset);
                                }
                                this.sendMidiNote(
                                    parseInt(this.midiOutNoteInput.value),
                                    effectiveVelocity,
                                    effectivePan,
                                    0.1, // MIDI note duration
                                    effectiveStartTimeOffset
                                );
                            }
                        }
                    });
                }
                this.draw();
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.isMuted) {
                    this.playStopButton.textContent = 'Muted';
                    this.playStopButton.classList.add('stop');
                    this.soloButton.classList.remove('active'); // Muting automatically unsolos if active
                    if (globalSoloedId === this.id) { // If it was soloed and now muted, clear global solo state
                        globalSoloedId = null;
                        preSoloMuteStates.clear(); // Clear previous states if solo is broken
                    }
                } else {
                    this.playStopButton.textContent = 'Unmuted';
                    this.playStopButton.classList.remove('stop');
                }
            }


            // --- Audio Functions ---
            async loadWavFile(fileOrPath) {
                initAudioContext();
                let file = null;
                let path = null;

                if (typeof fileOrPath === 'string') {
                    path = fileOrPath;
                } else if (fileOrPath && fileOrPath.target && fileOrPath.target.files && fileOrPath.target.files[0]) {
                    file = fileOrPath.target.files[0];
                } else {
                    console.warn("No file or valid path provided for loadWavFile.");
                    return;
                }

                try {
                    let arrayBuffer;
                    let fileNameForDisplay = '';

                    if (file) {
                        arrayBuffer = await file.arrayBuffer();
                        fileNameForDisplay = file.name;
                    } else if (path) {
                        const response = await fetch(path);
                        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                        arrayBuffer = await response.arrayBuffer();
                        fileNameForDisplay = path.split('/').pop();
                    } else {
                        return;
                    }
                    
                    audioContext.decodeAudioData(arrayBuffer, (buffer) => {
                        this.audioBuffer = buffer;
                        this.waveformData = buffer.getChannelData(0);
                        this.wavFileName = fileNameForDisplay;
                        this.wavFileNameSpan.textContent = fileNameForDisplay;
                        console.log(`Sequencer ${this.id}: WAV file loaded successfully: ${fileNameForDisplay}`);
                    }, (error) => {
                        console.error(`Sequencer ${this.id}: Error decoding audio data:`, error);
                        alert(`Sequencer ${this.id}: Could not decode audio file. Make sure it's a valid WAV.`);
                        this.audioBuffer = null;
                        this.waveformData = null;
                        this.wavFileName = '';
                        this.wavFileNameSpan.textContent = 'No file selected';
                    });
                } catch (error) {
                    console.error(`Sequencer ${this.id}: Error loading WAV file:`, error);
                    alert(`Sequencer ${this.id}: Error loading WAV file. Check if 'sounds/' folder exists and files are present, or if path is correct.`);
                    this.audioBuffer = null;
                    this.waveformData = null;
                    this.wavFileName = '';
                    this.wavFileNameSpan.textContent = 'No file selected';
                }
            }

            playSound(velocity, pan, startTimeOffset = 0) {
                if (!this.audioBuffer || !audioContext || this.isMuted) return;

                const source = audioContext.createBufferSource();
                source.buffer = this.audioBuffer;

                const gainNode = audioContext.createGain();
                gainNode.gain.value = velocity / 127; // Scale by per-circle velocity
                const pannerNode = audioContext.createStereoPanner();
                pannerNode.pan.value = pan; // Apply per-circle pan

                source.connect(gainNode);
                gainNode.connect(pannerNode);
                pannerNode.connect(this.sequencerGainNode); // Route through sequencer's main gain/panner before masterInputMixer
                
                source.start(audioContext.currentTime + startTimeOffset); // Apply timing offset here
                this.audioPlayingSource = source; // Keep track for waveform drawing

                source.onended = () => {
                    this.audioPlayingSource = null;
                    source.disconnect();
                    gainNode.disconnect();
                    pannerNode.disconnect();
                };
            }

            // --- Circle Management ---
            selectCircle(index) {
                // Deselect any previously selected circle
                if (selectedCircle.sequencer) {
                    selectedCircle.sequencer.deselectCircle();
                }

                selectedCircle.sequencer = this;
                selectedCircle.circleIndex = index;

                const circle = this.circles[index];
                // Only show controls if in 'edit' mode for this sequencer
                if (this.editMode === 'edit' && circle) {
                    // Update new X Position and X Ratio inputs (NEW)
                    circleXPositionInput.value = circle.x.toFixed(0);
                    circleXRatioInput.value = (circle.x / this.canvasWidth).toFixed(3);

                    circleVelocitySlider.value = circle.velocity;
                    circleVelocityValueSpan.textContent = circle.velocity;
                    circlePanSlider.value = Math.round(circle.pan * 100); // Display as -100 to 100
                    circlePanValueSpan.textContent = Math.round(circle.pan * 100);
                    selectedCircleControlsDiv.style.display = 'flex';
                } else {
                    selectedCircleControlsDiv.style.display = 'none';
                }
                this.draw(); // Redraw to highlight selected circle
            }

            deselectCircle() {
                if (selectedCircle.sequencer === this && selectedCircle.circleIndex !== -1) {
                    selectedCircle.sequencer = null;
                    selectedCircle.circleIndex = -1;
                    selectedCircleControlsDiv.style.display = 'none';
                    this.draw(); // Redraw to remove highlight
                }
            }

            // NEW: Update circle position from X Position input
            updateCircleXPosition(newX) {
                if (selectedCircle.sequencer === this && selectedCircle.circleIndex !== -1) {
                    const circle = this.circles[selectedCircle.circleIndex];
                    let clampedX = Math.max(0, Math.min(this.canvasWidth, parseFloat(newX)));
                    circle.x = clampedX;
                    circleXPositionInput.value = clampedX.toFixed(0);
                    circleXRatioInput.value = (clampedX / this.canvasWidth).toFixed(3);
                    this.circles.sort((a, b) => a.x - b.x);
                    this.draw();
                }
            }

            // NEW: Update circle position from X Ratio input
            updateCircleXRatio(newRatio) {
                if (selectedCircle.sequencer === this && selectedCircle.circleIndex !== -1) {
                    const circle = this.circles[selectedCircle.circleIndex];
                    let clampedRatio = Math.max(0, Math.min(1, parseFloat(newRatio)));
                    circle.x = clampedRatio * this.canvasWidth;
                    circleXPositionInput.value = circle.x.toFixed(0);
                    circleXRatioInput.value = clampedRatio.toFixed(3);
                    this.circles.sort((a, b) => a.x - b.x);
                    this.draw();
                }
            }


            applyDivisionSetting() {
                const divisionValue = parseFraction(this.divisionInput.value);
                if (divisionValue === null || divisionValue <= 0) {
                    alert('Invalid division input. Please use a fraction (e.g., 1/4) or a decimal (e.g., 0.5).');
                    return;
                }

                this.circles = [];
                const numCircles = Math.round(globalLoopBeats / divisionValue); // Use globalLoopBeats

                if (numCircles < 1 || numCircles > 64) {
                    alert('Division results in too few or too many steps. Try a value between 1/32 and ' + globalLoopBeats + '.');
                    return;
                }

                // FIX: Distribute circles evenly across the entire canvas width
                for (let i = 0; i < numCircles; i++) {
                    const x = (i / numCircles) * this.canvasWidth;
                    this.circles.push({ x: x, played: false, velocity: 100, pan: 0 }); // Add default velocity and pan
                }
                this.draw();
            }

            generateRandomBeat() {
                const possibleDivisions = ["1/4", "1/8", "1/16", "1/3", "1/6", "1/12", "0.25", "0.5", "1"]; // Example divisions
                const randomDivision = possibleDivisions[Math.floor(Math.random() * possibleDivisions.length)];
                this.divisionInput.value = randomDivision;
                
                const divisionValue = parseFraction(randomDivision);
                if (divisionValue === null || divisionValue <= 0) {
                    console.warn(`Sequencer ${this.id}: Invalid division for random beat generation. Skipping.`);
                    return;
                }

                this.circles = []; // Clear existing circles
                const numPotentialSlots = Math.round(globalLoopBeats / divisionValue);
                if (numPotentialSlots < 1 || numPotentialSlots > 64) {
                    console.warn(`Sequencer ${this.id}: Division results in too few or too many steps for random beat generation. Skipping.`);
                    return;
                }

                for (let i = 0; i < numPotentialSlots; i++) {
                    if (Math.random() < 0.5) { // 50% chance to add a beat
                        const x = (i / numPotentialSlots) * this.canvasWidth; // Use corrected x calculation
                        const velocity = Math.round(60 + Math.random() * 60); 
                        const pan = (Math.random() * 1.4 - 0.7).toFixed(2);
                        this.circles.push({ x: x, played: false, velocity: velocity, pan: parseFloat(pan) });
                    }
                }
                this.draw();
                console.log(`Sequencer ${this.id}: Random beat generated.`);
            }

            // NEW: Apply preset rhythm
            applyPresetRhythm(event, presetName = null) {
                const selectedPreset = presetName || this.presetRhythmsSelect.value;
                this.presetRhythm = selectedPreset; // Store selected preset name

                const rhythmPattern = SEQUENCER_PRESET_RHYTHMS[selectedPreset];

                if (rhythmPattern) {
                    this.circles = []; // Clear existing circles
                    rhythmPattern.forEach(beat => {
                        const x = beat.ratioX * this.canvasWidth;
                        this.circles.push({
                            x: x,
                            played: false,
                            velocity: beat.velocity,
                            pan: beat.pan
                        });
                    });
                    this.circles.sort((a, b) => a.x - b.x); // Keep sorted by x position
                    this.draw();
                    console.log(`Sequencer ${this.id}: Applied preset rhythm: ${selectedPreset}`);
                } else {
                    console.warn(`Sequencer ${this.id}: Preset rhythm '${selectedPreset}' not found.`);
                }
            }


            // --- Remove Sequencer ---
            remove() {
                const index = activeSequencers.findIndex(seq => seq.id === this.id);
                if (index !== -1) {
                    activeSequencers.splice(index, 1);
                }
                this.sequencerDiv.remove();
                console.log(`Sequencer ${this.id} removed.`);
                
                // If the removed sequencer had a selected circle, deselect it
                if (selectedCircle.sequencer === this) {
                    this.deselectCircle();
                }
                // If the removed sequencer was soloed, clear solo state
                if (globalSoloedId === this.id) {
                    globalSoloedId = null;
                    preSoloMuteStates.clear();
                    activeSequencers.forEach(seq => {
                        seq.isMuted = preSoloMuteStates.get(seq.id) || false; // Restore pre-solo mute state for all
                        seq.playStopButton.classList.remove('stop');
                        seq.playStopButton.textContent = 'Unmuted';
                        seq.soloButton.classList.remove('active');
                    });
                     // If global playback was started by solo, stop it.
                    if (isPlayingGlobal) toggleGlobalPlayStop();
                }
            }

            // --- Reset for Playback ---
            resetPlaybackState() {
                // this.verticalLineX = 0; // Vertical line tracks globalLoopTime, reset is handled there
                this.circles.forEach(c => c.played = false);
                this.draw();
            }
        }

        // --- Global Animation Loop ---
        let globalAnimationFrameId;

        function globalAnimate(currentTime) {
            if (!isPlayingGlobal) {
                lastGlobalUpdateTime = performance.now(); // Reset for next play
                return;
            }

            if (!lastGlobalUpdateTime) {
                lastGlobalUpdateTime = currentTime;
            }

            const deltaTime = (currentTime - lastGlobalUpdateTime) / 1000; // Convert to seconds
            lastGlobalUpdateTime = currentTime;

            const loopDuration = globalBeatDuration * globalLoopBeats;
            globalLoopTime += deltaTime;
            if (globalLoopTime >= loopDuration) {
                globalLoopTime -= loopDuration;
                activeSequencers.forEach(seq => seq.resetPlaybackState()); // Reset played state for all circles in all sequencers
            }

            activeSequencers.forEach(seq => seq.tick(deltaTime));

            globalAnimationFrameId = requestAnimationFrame(globalAnimate);
        }

        function toggleGlobalPlayStop() {
            isPlayingGlobal = !isPlayingGlobal;
            if (isPlayingGlobal) {
                globalPlayStopButton.textContent = 'Stop All';
                globalPlayStopButton.classList.add('stop');
                lastGlobalUpdateTime = performance.now(); // Initialize for accurate delta time
                globalLoopTime = 0; // Reset global time
                activeSequencers.forEach(seq => seq.resetPlaybackState()); // Ensure all start from beginning
                globalAnimationFrameId = requestAnimationFrame(globalAnimate);
                console.log("Global Playback Started.");
            } else {
                globalPlayStopButton.textContent = 'Play All';
                globalPlayStopButton.classList.remove('stop');
                cancelAnimationFrame(globalAnimationFrameId);
                globalLoopTime = 0;
                activeSequencers.forEach(seq => seq.resetPlaybackState());
                console.log("Global Playback Stopped.");
            }
        }

        function updateGlobalTempo() {
            const newBPM = parseInt(tempoBPMInput.value);
            if (!isNaN(newBPM) && newBPM >= 30 && newBPM <= 300) {
                globalTempoBPM = newBPM;
                globalBeatDuration = 60 / globalTempoBPM;
                console.log(`Global Tempo updated to ${globalTempoBPM} BPM.`);

                // Update delay time if delay is active and based on beats
                activeDelayInstances.forEach(delayInstance => {
                    if (delayInstance.isDelayOn && delayInstance.audioNodes) {
                        delayInstance.audioNodes.delay.delayTime.value = parseFloat(delayInstance.dom.delayTimeSlider.value) * globalBeatDuration;
                    }
                });

                // If playing, reset global time to resync with new tempo immediately
                if (isPlayingGlobal) {
                    cancelAnimationFrame(globalAnimationFrameId);
                    globalLoopTime = 0;
                    activeSequencers.forEach(seq => seq.resetPlaybackState());
                    lastGlobalUpdateTime = performance.now();
                    globalAnimationFrameId = requestAnimationFrame(globalAnimate);
                }
            } else {
                alert('Invalid BPM. Please enter a number between 30 and 300.');
                tempoBPMInput.value = globalTempoBPM; // Revert to last valid
            }
        }

        function updateGlobalLoopBeats() {
            const newLoopBeats = parseInt(loopBeatsInput.value);
            if (!isNaN(newLoopBeats) && newLoopBeats >=1 && newLoopBeats <= 16) {
                const oldLoopBeats = globalLoopBeats; // Store old value
                globalLoopBeats = newLoopBeats;
                console.log(`Loop Beats updated to ${globalLoopBeats}`);
                // NO LONGER automatically call applyDivisionSetting() on all sequencers (NEW)
                // Existing circles will remain at their absolute X positions.
                
                // If playing, reset global time to resync with new loop length
                if (isPlayingGlobal) {
                    cancelAnimationFrame(globalAnimationFrameId);
                    globalLoopTime = 0;
                    activeSequencers.forEach(seq => seq.resetPlaybackState());
                    lastGlobalUpdateTime = performance.now();
                    globalAnimationFrameId = requestAnimationFrame(globalAnimate);
                }
                // Update delay time if delay is active and based on beats (as globalBeatDuration may implicitly change loop duration)
                activeDelayInstances.forEach(delayInstance => {
                    if (delayInstance.isDelayOn && delayInstance.audioNodes) {
                        delayInstance.audioNodes.delay.delayTime.value = parseFloat(delayInstance.dom.delayTimeSlider.value) * globalBeatDuration;
                    }
                });
            } else {
                alert('Invalid Loop Beats. Please enter a number between 1 and 16.');
                loopBeatsInput.value = globalLoopBeats;
            }
        }


        let sequencerIdCounter = 0;
        function addSequencer(savedSettings = {}) {
            sequencerIdCounter++;
            const newSequencer = new Sequencer(sequencerIdCounter, sequencerContainer, savedSettings);
            activeSequencers.push(newSequencer);
        }

        function generateRandomBeats() {
            if (activeSequencers.length === 0) {
                alert("Please add at least one sequencer first.");
                return;
            }

            activeSequencers.forEach(seq => {
                seq.generateRandomBeat(); // Call the sequencer's specific method
            });
            console.log("Random beats generated for all sequencers.");
        }


        // --- Skin Selection ---
        function applySkin(skinName) {
            document.body.className = skinName;
            activeSequencers.forEach(seq => seq.draw());
            drawGlobalWaveform(); 
        }

        // --- Collapsible Sections ---
        function setupCollapsibles() {
            document.querySelectorAll('.collapsible-header').forEach(header => {
                const targetId = header.dataset.target;
                const targetContent = document.getElementById(targetId);
                const button = header.querySelector('.toggle-collapse-button');

                if (targetContent && button) {
                    // Initial state for Effects and Humanizer is collapsed by default if nothing saved
                    if (targetContent.classList.contains('collapsed')) {
                        button.textContent = '▼';
                    } else {
                        button.textContent = '▲';
                    }

                    header.addEventListener('click', (event) => {
                        // Only collapse if the click wasn't on the button itself (to avoid double toggle)
                        if (event.target !== button) {
                            targetContent.classList.toggle('collapsed');
                            button.textContent = targetContent.classList.contains('collapsed') ? '▼' : '▲';
                        }
                    });
                    button.addEventListener('click', (event) => {
                         event.stopPropagation(); // Prevent header's click from firing
                         targetContent.classList.toggle('collapsed');
                         button.textContent = targetContent.classList.contains('collapsed') ? '▼' : '▲';
                    });
                }
            });
        }


        // --- Save/Load Settings ---
        function saveSettings() {
            const settings = {
                tempo: globalTempoBPM,
                loopBeats: globalLoopBeats,
                skin: skinSelection.value,
                masterVolume: masterVolumeSlider.value,
                
                // Chorus Settings
                isChorusOn: isChorusOn,
                chorusRate: chorusRateSlider.value,
                chorusDepth: chorusDepthSlider.value,
                chorusFeedback: chorusFeedbackSlider.value,
                chorusMix: chorusMixSlider.value,

                // Flanger Settings
                isFlangerOn: isFlangerOn,
                flangerRate: flangerRateSlider.value,
                flangerDepth: flangerDepthSlider.value,
                flangerFeedback: flangerFeedbackSlider.value,
                flangerMix: flangerMixSlider.value,

                // Phaser Settings
                isPhaserOn: isPhaserOn,
                phaserRate: phaserRateSlider.value,
                phaserDepth: phaserDepthSlider.value,
                phaserFeedback: phaserFeedbackSlider.value,
                phaserFrequency: phaserFrequencySlider.value,
                phaserStages: phaserStagesInput.value,
                phaserMix: phaserMixSlider.value,
                
                // Reverb Settings
                isReverbOn: isReverbOn,
                reverbType: reverbTypeSelect.value,
                reverbAmount: reverbAmountSlider.value,
                reverbDecay: reverbDecaySlider.value,
                reverbDiffusion: reverbDiffusionSlider.value,
                reverbLowpass: reverbLowpassSlider.value,
                reverbHighpass: reverbHighpassSlider.value, // NEW Reverb HPF
                
                // Delay Instances Settings
                delayInstances: activeDelayInstances.map(instance => ({
                    id: instance.id,
                    isDelayOn: instance.isDelayOn,
                    delayTime: instance.dom.delayTimeSlider.value,
                    delayFeedback: instance.dom.delayFeedbackSlider.value,
                    delayMix: instance.dom.delayMixSlider.value,
                    delayPan: instance.dom.delayPanSlider.value, // NEW Delay Pan
                    delayLowpass: instance.dom.delayLowpassSlider.value, // NEW Delay LPF
                    delayHighpass: instance.dom.delayHighpassSlider.value, // NEW Delay HPF
                })),

                // Humanizer Settings
                isHumanizerOn: isHumanizerOn,
                humanizeTiming: humanizeTimingSlider.value,
                humanizeVelocity: humanizeVelocitySlider.value,
                humanizePan: humanizePanSlider.value,

                // Collapsible states
                humanizerControlsCollapsed: humanizerControlsDiv.classList.contains('collapsed'),
                effectsControlsCollapsed: effectsControlsDiv.classList.contains('collapsed'),

                sequencers: []
            };

            activeSequencers.forEach(seq => {
                settings.sequencers.push({
                    id: seq.id,
                    circles: seq.circles.map(c => ({ x: c.x, velocity: c.velocity, pan: c.pan })),
                    division: seq.divisionInput.value,
                    channel: seq.midiOutChannelInput.value,
                    note: seq.midiOutNoteInput.value,
                    wavFileName: seq.wavFileName,
                    isMuted: seq.isMuted,
                    volume: seq.sequencerVolumeSlider.value,
                    pan: seq.sequencerPanSlider.value,
                    phase: seq.phase,
                    editMode: seq.editMode,
                    presetRhythm: seq.presetRhythmsSelect.value, // NEW Preset Rhythm
                    isSoloed: (globalSoloedId === seq.id) // Save solo state
                });
            });

            downloadFile(JSON.stringify(settings, null, 2), `sequencer_settings_${Date.now()}.json`, 'application/json');
            console.log("Settings saved.");
        }

        function applyLoadedSettings(loadedSettings) {
            // Stop and clear current state
            if (isPlayingGlobal) toggleGlobalPlayStop();
            activeSequencers.forEach(seq => seq.remove()); // This also clears from activeSequencers
            activeSequencers = []; // Ensure empty
            globalSoloedId = null; // Clear solo state from previous session

            // Clear all dynamic delay instances
            while(activeDelayInstances.length > 0) {
                removeDelayInstance(activeDelayInstances[0].id);
            }
            delayIdCounter = 0; // Reset delay counter

            // Apply global settings
            globalTempoBPM = loadedSettings.tempo || 120;
            tempoBPMInput.value = globalTempoBPM;
            
            globalLoopBeats = loadedSettings.loopBeats !== undefined ? loadedSettings.loopBeats : 4;
            loopBeatsInput.value = globalLoopBeats;
            
            updateGlobalTempo(); // This will also update globalBeatDuration and handle delay time

            skinSelection.value = loadedSettings.skin || 'dark';
            applySkin(skinSelection.value);

            masterVolumeSlider.value = loadedSettings.masterVolume !== undefined ? loadedSettings.masterVolume : 0.75;
            masterGainNode.gain.value = parseFloat(masterVolumeSlider.value);
            masterVolumeValueSpan.textContent = `${(masterGainNode.gain.value * 100).toFixed(0)}%`;

            // Chorus Settings
            isChorusOn = loadedSettings.isChorusOn !== undefined ? loadedSettings.isChorusOn : false;
            chorusRateSlider.value = loadedSettings.chorusRate !== undefined ? loadedSettings.chorusRate : 1.0;
            chorusDepthSlider.value = loadedSettings.chorusDepth !== undefined ? loadedSettings.chorusDepth : 0.005;
            chorusFeedbackSlider.value = loadedSettings.chorusFeedback !== undefined ? loadedSettings.chorusFeedback : 0.0;
            chorusMixSlider.value = loadedSettings.chorusMix !== undefined ? loadedSettings.chorusMix : 0.0;
            // Set effects on/off, then update controls
            if (isChorusOn) { chorusOnOffButton.textContent = 'Chorus On'; chorusOnOffButton.style.backgroundColor = varCSS('--primary-color'); }
            else { chorusOnOffButton.textContent = 'Chorus Off'; chorusOnOffButton.style.backgroundColor = varCSS('--input-bg'); }
            if (chorusOnOffGain) chorusOnOffGain.gain.value = isChorusOn ? 1 : 0;
            updateChorusControls();

            // Flanger Settings
            isFlangerOn = loadedSettings.isFlangerOn !== undefined ? loadedSettings.isFlangerOn : false;
            flangerRateSlider.value = loadedSettings.flangerRate !== undefined ? loadedSettings.flangerRate : 0.5;
            flangerDepthSlider.value = loadedSettings.flangerDepth !== undefined ? loadedSettings.flangerDepth : 0.002;
            flangerFeedbackSlider.value = loadedSettings.flangerFeedback !== undefined ? loadedSettings.flangerFeedback : 0.0;
            flangerMixSlider.value = loadedSettings.flangerMix !== undefined ? loadedSettings.flangerMix : 0.0;
            if (isFlangerOn) { flangerOnOffButton.textContent = 'Flanger On'; flangerOnOffButton.style.backgroundColor = varCSS('--primary-color'); }
            else { flangerOnOffButton.textContent = 'Flanger Off'; flangerOnOffButton.style.backgroundColor = varCSS('--input-bg'); }
            if (flangerOnOffGain) flangerOnOffGain.gain.value = isFlangerOn ? 1 : 0;
            updateFlangerControls();

            // Phaser Settings
            isPhaserOn = loadedSettings.isPhaserOn !== undefined ? loadedSettings.isPhaserOn : false;
            phaserRateSlider.value = loadedSettings.phaserRate !== undefined ? loadedSettings.phaserRate : 0.2;
            phaserDepthSlider.value = loadedSettings.phaserDepth !== undefined ? loadedSettings.phaserDepth : 1.0;
            phaserFeedbackSlider.value = loadedSettings.phaserFeedback !== undefined ? loadedSettings.phaserFeedback : 0.0;
            phaserFrequencySlider.value = loadedSettings.phaserFrequency !== undefined ? loadedSettings.phaserFrequency : 300;
            phaserStagesInput.value = loadedSettings.phaserStages !== undefined ? loadedSettings.phaserStages : 4;
            phaserMixSlider.value = loadedSettings.phaserMix !== undefined ? loadedSettings.phaserMix : 0.0;
            if (isPhaserOn) { phaserOnOffButton.textContent = 'Phaser On'; phaserOnOffButton.style.backgroundColor = varCSS('--primary-color'); }
            else { phaserOnOffButton.textContent = 'Phaser Off'; phaserOnOffButton.style.backgroundColor = varCSS('--input-bg'); }
            if (phaserOnOffGain) phaserOnOffGain.gain.value = isPhaserOn ? 1 : 0;
            updatePhaserControls();


            // Reverb Settings
            isReverbOn = loadedSettings.isReverbOn !== undefined ? loadedSettings.isReverbOn : false;
            reverbTypeSelect.value = loadedSettings.reverbType || defaultReverbType;
            reverbAmountSlider.value = loadedSettings.reverbAmount !== undefined ? loadedSettings.reverbAmount : 0.0;
            reverbDecaySlider.value = loadedSettings.reverbDecay !== undefined ? loadedSettings.reverbDecay : 1.0;
            reverbDiffusionSlider.value = loadedSettings.reverbDiffusion !== undefined ? loadedSettings.reverbDiffusion : 0.5;
            reverbLowpassSlider.value = loadedSettings.reverbLowpass !== undefined ? loadedSettings.reverbLowpass : 8000;
            reverbHighpassSlider.value = loadedSettings.reverbHighpass !== undefined ? loadedSettings.reverbHighpass : 0; // NEW
            if (isReverbOn) { reverbOnOffButton.textContent = 'Reverb On'; reverbOnOffButton.style.backgroundColor = varCSS('--primary-color'); }
            else { reverbOnOffButton.textContent = 'Reverb Off'; reverbOnOffButton.style.backgroundColor = varCSS('--input-bg'); }
            if (reverbOnOffGain) reverbOnOffGain.gain.value = isReverbOn ? 1 : 0;
            updateReverbControls(); // Apply all reverb params

            // Delay Instances (NEW)
            if (loadedSettings.delayInstances && Array.isArray(loadedSettings.delayInstances)) {
                loadedSettings.delayInstances.forEach(delayData => {
                    addDelayInstance(delayData);
                });
            }
            
            // Humanizer Settings
            isHumanizerOn = loadedSettings.isHumanizerOn !== undefined ? loadedSettings.isHumanizerOn : false;
            humanizeTimingSlider.value = loadedSettings.humanizeTiming !== undefined ? loadedSettings.humanizeTiming : 0;
            humanizeVelocitySlider.value = loadedSettings.humanizeVelocity !== undefined ? loadedSettings.humanizeVelocity : 0;
            humanizePanSlider.value = loadedSettings.humanizePan !== undefined ? loadedSettings.humanizePan : 0;
            if (isHumanizerOn) { humanizerOnOffButton.textContent = 'Humanizer On'; humanizerOnOffButton.style.backgroundColor = varCSS('--primary-color'); }
            else { humanizerOnOffButton.textContent = 'Humanizer Off'; humanizerOnOffButton.style.backgroundColor = varCSS('--input-bg'); }
            updateHumanizerControls(); // Update display spans

            // Collapsible states
            const humanizerButton = document.querySelector('.collapsible-header[data-target="humanizerControls"] .toggle-collapse-button');
            const effectsButton = document.querySelector('.collapsible-header[data-target="effectsControls"] .toggle-collapse-button');

            if (loadedSettings.humanizerControlsCollapsed) {
                humanizerControlsDiv.classList.add('collapsed');
                if (humanizerButton) humanizerButton.textContent = '▼';
            } else {
                humanizerControlsDiv.classList.remove('collapsed');
                if (humanizerButton) humanizerButton.textContent = '▲';
            }

            if (loadedSettings.effectsControlsCollapsed) {
                effectsControlsDiv.classList.add('collapsed');
                if (effectsButton) effectsButton.textContent = '▼';
            } else {
                effectsControlsDiv.classList.remove('collapsed');
                if (effectsButton) effectsButton.textContent = '▲';
            }


            // Recreate sequencers
            sequencerIdCounter = 0; // Reset counter for new IDs
            let wavFilesToReupload = [];
            let soloedSequencerIdFromSettings = null; // Track if any sequencer was soloed in settings

            loadedSettings.sequencers.forEach(seqData => {
                addSequencer(seqData); // Pass all data, constructor handles it
                // Check if the loaded WAV file name corresponds to a preloaded sound, otherwise alert the user
                const currentSeq = activeSequencers[activeSequencers.length -1];
                if (seqData.wavFileName && seqData.wavFileName !== 'No file selected' && !preloadedSounds.some(s => s.path.endsWith(seqData.wavFileName))) {
                    wavFilesToReupload.push(`Sequencer ${currentSeq.id}: ${seqData.wavFileName}`);
                }
                if (seqData.isSoloed) { // If this sequencer was soloed in the saved settings
                    soloedSequencerIdFromSettings = currentSeq.id;
                }
            });

            // After all sequencers are created, apply the solo state
            if (soloedSequencerIdFromSettings !== null) {
                const soloedSeq = activeSequencers.find(seq => seq.id === soloedSequencerIdFromSettings);
                if (soloedSeq) {
                    // Manually set globalSoloedId and update visual states, but don't call toggleSequencerPlayback
                    // as it would re-store preSoloMuteStates which we want to avoid for initial load.
                    globalSoloedId = soloedSeq.id;
                    activeSequencers.forEach(seq => {
                        preSoloMuteStates.set(seq.id, seq.isMuted); // Store whatever mute state it loaded with
                        if (seq.id === globalSoloedId) {
                            seq.isMuted = false;
                            seq.playStopButton.classList.remove('stop');
                            seq.playStopButton.textContent = 'Unmuted';
                            seq.soloButton.classList.add('active');
                        } else {
                            seq.isMuted = true;
                            seq.playStopButton.classList.add('stop');
                            seq.playStopButton.textContent = 'Muted';
                            seq.soloButton.classList.remove('active');
                        }
                    });
                     // Start global playback for the soloed track
                    toggleGlobalPlayStop();
                }
            }


            if (wavFilesToReupload.length > 0) {
                alert("Settings loaded! Please re-upload the following WAV files for the respective sequencers if they are not preloaded:\n" + wavFilesToReupload.join('\n'));
            } else {
                alert("Settings loaded!");
            }
            console.log("Settings loaded.");
        }

        function loadSettingsFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const loadedSettings = JSON.parse(e.target.result);
                    applyLoadedSettings(loadedSettings);
                } catch (error) {
                    console.error("Error loading settings:", error);
                    alert("Failed to load settings. Make sure it's a valid JSON file.");
                }
            };
            reader.readAsText(file);
        }

        function loadDemoSequence(event) {
            const selectedIndex = event.target.value;
            if (selectedIndex === "") return;

            const demoConfig = demoConfigs[parseInt(selectedIndex)];
            if (demoConfig) {
                applyLoadedSettings(demoConfig);
            } else {
                console.error("Demo configuration not found for index:", selectedIndex);
            }
            event.target.value = ""; // Reset dropdown after selection
        }


        // --- Save to MIDI ---
        function saveToMidi() {
            if (activeSequencers.length === 0) {
                alert("Add at least one sequencer to save to MIDI.");
                return;
            }

            const PPQ = 480; // Pulses Per Quarter note (standard MIDI resolution)
            const trackEvents = [];
            const loopDuration = globalBeatDuration * globalLoopBeats;
            const totalMidiTicks = globalLoopBeats * PPQ; // Total ticks for one loop

            // Collect all note events from all sequencers
            activeSequencers.forEach(seq => {
                // Don't save muted or non-soloed tracks. 
                // If a track is soloed, only that track is considered for export.
                const shouldExport = !seq.isMuted && (globalSoloedId === null || globalSoloedId === seq.id);
                if (!shouldExport) return; 

                const midiChannel = parseInt(seq.midiOutChannelInput.value) - 1; // 0-15
                const midiNote = parseInt(seq.midiOutNoteInput.value);
                const noteDurationSeconds = 0.1;

                if (isNaN(midiChannel) || isNaN(midiNote) || midiChannel < 0 || midiChannel > 15 || midiNote < 0 || midiNote > 127) {
                    console.warn(`Sequencer ${seq.id}: Invalid MIDI settings, skipping.`);
                    return;
                }

                seq.circles.forEach(circle => {
                    // Apply humanize effects for export (simplified: direct application)
                    let effectiveVelocity = circle.velocity;
                    let effectivePan = circle.pan;
                    let effectiveTimingOffsetSeconds = 0; // For MIDI, we apply offset as part of tick calculation

                    if (isHumanizerOn) { // Only apply if humanizer is ON
                        const humanizeTimingAmount = parseFloat(humanizeTimingSlider.value) / 1000;
                        const humanizeVelocityAmount = parseFloat(humanizeVelocitySlider.value) / 100;
                        const humanizePanAmount = parseFloat(humanizePanSlider.value) / 100;

                        if (humanizeVelocityAmount > 0) {
                            effectiveVelocity = Math.round(effectiveVelocity * (1 + (Math.random() * 2 - 1) * humanizeVelocityAmount));
                            effectiveVelocity = Math.min(127, Math.max(0, effectiveVelocity));
                        }
                        if (humanizePanAmount > 0) {
                            effectivePan = Math.max(-1, Math.min(1, effectivePan + (Math.random() * 2 - 1) * humanizePanAmount));
                        }
                        if (humanizeTimingAmount > 0) {
                            effectiveTimingOffsetSeconds = (Math.random() * 2 - 1) * humanizeTimingAmount;
                        }
                    }

                    // Apply sequencer phase to the circle's position
                    const phaseOffsetSeconds = (seq.phase / 100) * loopDuration;

                    const circleLoopRatio = circle.x / seq.canvasWidth;
                    let eventTimeSeconds = (circleLoopRatio * loopDuration) + phaseOffsetSeconds + effectiveTimingOffsetSeconds;
                    
                    // Normalize eventTimeSeconds to be within [0, loopDuration)
                    eventTimeSeconds = eventTimeSeconds % loopDuration;
                    if (eventTimeSeconds < 0) {
                        eventTimeSeconds += loopDuration;
                    }


                    const eventTick = Math.round((eventTimeSeconds / loopDuration) * totalMidiTicks);
                    const noteDurationTicks = Math.round((noteDurationSeconds / globalBeatDuration) * PPQ); // Duration relative to one beat
                    // Clamp noteOffTick to totalMidiTicks to ensure it doesn't exceed the loop length in the MIDI file
                    const noteOffTick = Math.min(totalMidiTicks, Math.round(eventTick + noteDurationTicks));

                    trackEvents.push({ type: 'noteOn', tick: eventTick, channel: midiChannel, note: midiNote, velocity: effectiveVelocity, pan: effectivePan });
                    trackEvents.push({ type: 'noteOff', tick: noteOffTick, channel: midiChannel, note: midiNote, velocity: effectiveVelocity, pan: effectivePan }); // Pan for note off too
                });
            });

            trackEvents.sort((a, b) => a.tick - b.tick); // Sort all events by time

            let lastTick = 0;
            const midiMessages = [];

            function encodeVLQ(value) {
                let bytes = [];
                let buffer = value & 0x7F;
                value >>= 7;
                while (value > 0) {
                    buffer |= 0x80;
                    bytes.push(buffer);
                    buffer = value & 0x7F;
                    value >>= 7;
                }
                bytes.push(buffer);
                return bytes.reverse();
            }

            // Delta-time encoding
            trackEvents.forEach(event => {
                const deltaTime = event.tick - lastTick;
                midiMessages.push(...encodeVLQ(deltaTime));

                if (event.type === 'noteOn') {
                    midiMessages.push(0x90 | event.channel, event.note, event.velocity);
                    // Add MIDI Pan CC#10
                    const midiPanValue = Math.round((event.pan + 1) * 63.5); // Convert -1 to 1 to 0 to 127
                    midiMessages.push(...encodeVLQ(0)); // Delta time for CC (0 as it's simultaneous)
                    midiMessages.push(0xB0 | event.channel, 10, midiPanValue);
                } else if (event.type === 'noteOff') {
                    midiMessages.push(0x80 | event.channel, event.note, event.velocity);
                }
                lastTick = event.tick;
            });

            midiMessages.push(...encodeVLQ(0)); // End of track delta time (0)
            midiMessages.push(0xFF, 0x2F, 0x00); // End of Track meta event

            // Build MIDI file binary
            const headerChunk = [0x4D, 0x54, 0x68, 0x64]; // MThd
            const headerSize = [0x00, 0x00, 0x00, 0x06]; // Length of header chunk (6 bytes)
            const format = [0x00, 0x00]; // Format 0 (single track)
            const numTracks = [0x00, 0x01]; // 1 track
            const division = [(PPQ >> 8) & 0xFF, PPQ & 0xFF]; // PPQ (e.g., 480)

            const trackChunk = [0x4D, 0x54, 0x72, 0x6B]; // MTrk
            const trackLength = midiMessages.length;
            const trackLengthBytes = [
                (trackLength >> 24) & 0xFF,
                (trackLength >> 16) & 0xFF,
                (trackLength >> 8) & 0xFF,
                trackLength & 0xFF
            ];

            const midiData = new Uint8Array([
                ...headerChunk, ...headerSize, ...format, ...numTracks, ...division,
                ...trackChunk, ...trackLengthBytes, ...midiMessages
            ]);

            downloadFile(midiData, `rhythm_sequence_${Date.now()}.mid`, 'audio/midi');
            console.log("MIDI file saved.");
            alert("MIDI file saved! (Note: This is a basic MIDI export.)");
        }

        // --- Save to WAV ---
        async function saveToWav() {
            if (activeSequencers.length === 0) {
                alert("Add at least one sequencer and load WAV files to save to WAV.");
                return;
            }

            const sampleRate = audioContext.sampleRate;
            const loopDuration = globalBeatDuration * globalLoopBeats; // Duration of one loop

            let totalMaxAudioBufferDuration = 0;
            activeSequencers.forEach(seq => {
                if (seq.audioBuffer) {
                    totalMaxAudioBufferDuration = Math.max(totalMaxAudioBufferDuration, seq.audioBuffer.duration);
                }
            });
            // Ensure rendered duration includes any sound tails after the last beat + some padding
            const renderingDuration = loopDuration + totalMaxAudioBufferDuration + 1.0; // Added 1.0s padding

            const offlineContext = new OfflineAudioContext(
                audioContext.destination.channelCount || 2,
                Math.ceil(sampleRate * renderingDuration),
                sampleRate
            );

            // Recreate the audio graph structure for offline rendering
            const offlineMasterInputMixer = offlineContext.createGain(); // Collects all sequencer outputs
            const offlineMasterGain = offlineContext.createGain();
            offlineMasterGain.gain.value = parseFloat(masterVolumeSlider.value);

            // Offline Analyser is not needed for rendering, but helps visualize connections
            // const offlineAnalyser = offlineContext.createAnalyser(); 
            // offlineAnalyser.connect(offlineMasterGain); 

            offlineMasterInputMixer.connect(offlineMasterGain); // Dry signal path

            // Chorus for offline context
            const offlineChorusNode = createChorusEffect(offlineContext);
            const offlineChorusOnOffGain = offlineContext.createGain();
            const offlineChorusWetGain = offlineContext.createGain();
            offlineChorusOnOffGain.gain.value = isChorusOn ? 1 : 0;
            offlineChorusWetGain.gain.value = parseFloat(chorusMixSlider.value);
            offlineMasterInputMixer.connect(offlineChorusOnOffGain);
            offlineChorusOnOffGain.connect(offlineChorusNode.input);
            offlineChorusNode.output.connect(offlineChorusWetGain);
            offlineChorusWetGain.connect(offlineMasterGain);
            offlineChorusNode.lfo.frequency.value = parseFloat(chorusRateSlider.value);
            offlineChorusNode.lfoGain.gain.value = parseFloat(chorusDepthSlider.value);
            offlineChorusNode.feedback.gain.value = parseFloat(chorusFeedbackSlider.value);


            // Flanger for offline context
            const offlineFlangerNode = createFlangerEffect(offlineContext);
            const offlineFlangerOnOffGain = offlineContext.createGain();
            const offlineFlangerWetGain = offlineContext.createGain();
            offlineFlangerOnOffGain.gain.value = isFlangerOn ? 1 : 0;
            offlineFlangerWetGain.gain.value = parseFloat(flangerMixSlider.value);
            offlineMasterInputMixer.connect(offlineFlangerOnOffGain);
            offlineFlangerOnOffGain.connect(offlineFlangerNode.input);
            offlineFlangerNode.output.connect(offlineFlangerWetGain);
            offlineFlangerWetGain.connect(offlineMasterGain);
            offlineFlangerNode.lfo.frequency.value = parseFloat(flangerRateSlider.value);
            offlineFlangerNode.lfoGain.gain.value = parseFloat(flangerDepthSlider.value);
            offlineFlangerNode.feedback.gain.value = parseFloat(flangerFeedbackSlider.value);

            // Phaser for offline context
            const offlinePhaserNode = createPhaserEffect(offlineContext); // Note: stages are fixed after creation
            const offlinePhaserOnOffGain = offlineContext.createGain();
            const offlinePhaserWetGain = offlineContext.createGain();
            offlinePhaserOnOffGain.gain.value = isPhaserOn ? 1 : 0;
            offlinePhaserWetGain.gain.value = parseFloat(phaserMixSlider.value);
            offlineMasterInputMixer.connect(offlinePhaserOnOffGain);
            offlinePhaserOnOffGain.connect(offlinePhaserNode.input);
            offlinePhaserNode.output.connect(offlinePhaserWetGain);
            offlinePhaserWetGain.connect(offlineMasterGain);
            offlinePhaserNode.lfo.frequency.value = parseFloat(phaserRateSlider.value);
            offlinePhaserNode.filters.forEach(filter => {
                filter.frequency.value = parseFloat(phaserFrequencySlider.value);
                filter.detune.value = 100 * parseFloat(phaserDepthSlider.value);
            });
            offlinePhaserNode.feedback.gain.value = parseFloat(phaserFeedbackSlider.value);


            // Reverb setup for offline context
            const offlineReverbNode = createAlgorithmicReverb(offlineContext);
            const offlineReverbOnOffGain = offlineContext.createGain();
            const offlineReverbWetGain = offlineContext.createGain();
            offlineReverbOnOffGain.gain.value = isReverbOn ? 1 : 0; // Use current state
            offlineReverbWetGain.gain.value = parseFloat(reverbAmountSlider.value);

            offlineMasterInputMixer.connect(offlineReverbOnOffGain); // Input to reverb gate
            offlineReverbOnOffGain.connect(offlineReverbNode.input);
            offlineReverbNode.output.connect(offlineReverbWetGain);
            offlineReverbWetGain.connect(offlineMasterGain);

            // Apply reverb parameters (decay, diffusion, lowpass, highpass)
            let currentPreset = reverbPresets[reverbTypeSelect.value];
            if (!currentPreset) currentPreset = reverbPresets['algorithmic'];

            offlineReverbNode.lowpassFilters.forEach(filter => filter.frequency.value = parseFloat(reverbLowpassSlider.value));
            offlineReverbNode.highpassFilter.frequency.value = parseFloat(reverbHighpassSlider.value); // NEW
            offlineReverbNode.feedbackGains.forEach((fb) => {
                fb.gain.value = 0.4 + (parseFloat(reverbDecaySlider.value) / 10) * 0.5;
                fb.gain.value = Math.min(0.98, Math.max(0.01, fb.gain.value));
            });
            offlineReverbNode.delays.forEach((delay, i) => {
                const diffusionVal = parseFloat(reverbDiffusionSlider.value);
                const delayTimesFactorVal = (reverbTypeSelect.value === 'algorithmic') ? 1.0 : currentPreset.delayTimesFactor;
                delay.delayTime.value = baseReverbDelayTimes[i] * delayTimesFactorVal * (1 + (diffusionVal * 0.5 * (Math.random() - 0.5)));
            });

            // Dynamic Delay instances for offline context
            activeDelayInstances.forEach(instance => {
                const offlineDelayNode = createDelayEffect(offlineContext); // Recreate for offline
                const offlineDelayOnOffGain = offlineContext.createGain();
                const offlineDelayWetGain = offlineContext.createGain();

                offlineDelayOnOffGain.gain.value = instance.isDelayOn ? 1 : 0;
                offlineDelayWetGain.gain.value = parseFloat(instance.dom.delayMixSlider.value);

                offlineMasterInputMixer.connect(offlineDelayOnOffGain); // Input to gate
                offlineDelayOnOffGain.connect(offlineDelayNode.input);
                offlineDelayNode.output.connect(offlineDelayWetGain);
                offlineDelayWetGain.connect(offlineMasterGain);

                offlineDelayNode.delay.delayTime.value = parseFloat(instance.dom.delayTimeSlider.value) * globalBeatDuration;
                offlineDelayNode.feedbackGain.gain.value = parseFloat(instance.dom.delayFeedbackSlider.value);
                offlineDelayNode.panner.pan.value = parseFloat(instance.dom.delayPanSlider.value); // NEW
                offlineDelayNode.lpf.frequency.value = parseFloat(instance.dom.delayLowpassSlider.value); // NEW
                offlineDelayNode.hpf.frequency.value = parseFloat(instance.dom.delayHighpassSlider.value); // NEW
            });


            offlineMasterGain.connect(offlineContext.destination);


            activeSequencers.forEach(seq => {
                // Determine if this sequencer should be rendered for WAV export
                const shouldRender = !seq.isMuted && (globalSoloedId === null || globalSoloedId === seq.id);
                if (!seq.audioBuffer || !shouldRender) return; // Skip if no buffer, muted, or not soloed

                const seqOfflineGain = offlineContext.createGain();
                seqOfflineGain.gain.value = parseFloat(seq.sequencerVolumeSlider.value); // Use sequencer's volume
                const seqOfflinePanner = offlineContext.createStereoPanner();
                seqOfflinePanner.pan.value = parseFloat(seq.sequencerPanSlider.value); // Use sequencer's pan

                seqOfflineGain.connect(seqOfflinePanner);
                seqOfflinePanner.connect(offlineMasterInputMixer); // Connect to the new master input mixer

                seq.circles.forEach(circle => {
                    const source = offlineContext.createBufferSource();
                    source.buffer = seq.audioBuffer;

                    // Apply humanize effects for export (simplified: direct application)
                    let effectiveVelocity = circle.velocity;
                    let effectivePan = circle.pan;
                    let effectiveTimingOffsetSeconds = 0;

                    if (isHumanizerOn) {
                        const humanizeTimingAmount = parseFloat(humanizeTimingSlider.value) / 1000;
                        const humanizeVelocityAmount = parseFloat(humanizeVelocitySlider.value) / 100;
                        const humanizePanAmount = parseFloat(humanizePanSlider.value) / 100;

                        if (humanizeVelocityAmount > 0) {
                            effectiveVelocity = Math.round(effectiveVelocity * (1 + (Math.random() * 2 - 1) * humanizeVelocityAmount));
                            effectiveVelocity = Math.min(127, Math.max(0, effectiveVelocity));
                        }
                        if (humanizePanAmount > 0) {
                            effectivePan = Math.max(-1, Math.min(1, effectivePan + (Math.random() * 2 - 1) * humanizePanAmount));
                        }
                        if (humanizeTimingAmount > 0) {
                            effectiveTimingOffsetSeconds = (Math.random() * 2 - 1) * humanizeTimingAmount;
                        }
                    }
                    
                    // Apply sequencer phase to the circle's position
                    const phaseOffsetSeconds = (seq.phase / 100) * loopDuration;

                    const circleLoopRatio = circle.x / seq.canvasWidth;
                    let startTime = (circleLoopRatio * loopDuration) + phaseOffsetSeconds + effectiveTimingOffsetSeconds;
                    startTime = startTime % loopDuration; // Wrap around
                    startTime = Math.max(0, startTime); // Ensure start time is not negative

                    // Individual circle gain and panner
                    const circleOfflineGain = offlineContext.createGain();
                    circleOfflineGain.gain.value = effectiveVelocity / 127; // Apply per-circle velocity
                    const circleOfflinePanner = offlineContext.createStereoPanner();
                    circleOfflinePanner.pan.value = effectivePan; // Apply per-circle pan

                    source.connect(circleOfflineGain);
                    circleOfflineGain.connect(circleOfflinePanner);
                    circleOfflinePanner.connect(seqOfflineGain); // Connect into the sequencer's main nodes

                    source.start(startTime);
                });
            });

            alert("Rendering WAV file... This may take a moment.");
            try {
                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = encodeWAV(renderedBuffer, offlineContext.sampleRate);
                downloadFile(wavBlob, `rhythm_sequence_${Date.now()}.wav`, 'audio/wav');
                console.log("WAV file saved.");
                alert("WAV file saved!");
            } catch (error) {
                console.error("Error rendering WAV:", error);
                alert("Failed to render WAV file. Check console for details.");
            }
        }

        // Basic WAV Encoder from AudioBuffer (Mono or Stereo)
        function encodeWAV(audioBuffer, sampleRate) {
            const numChannels = audioBuffer.numberOfChannels;
            const numSamples = audioBuffer.length;
            const bytesPerSample = 2; // 16-bit PCM
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;

            const buffer = new ArrayBuffer(44 + numSamples * numChannels * bytesPerSample);
            const view = new DataView(buffer);

            let offset = 0;

            function writeString(str) {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
                offset += str.length;
            }

            function writeUint32(val) {
                view.setUint32(offset, val, true); // true for little-endian
                offset += 4;
            }

            function writeUint16(val) {
                view.setUint16(offset, val, true); // true for little-endian
                offset += 2;
            }

            // RIFF chunk descriptor
            writeString('RIFF');
            writeUint32(36 + numSamples * numChannels * bytesPerSample); // File size - 8
            writeString('WAVE');

            // FMT sub-chunk
            writeString('fmt ');
            writeUint32(16); // Subchunk1Size for PCM
            writeUint16(1); // AudioFormat (1 = PCM)
            writeUint16(numChannels);
            writeUint32(sampleRate);
            writeUint32(byteRate);
            writeUint16(blockAlign);
            writeUint16(bytesPerSample * 8); // Bits per sample (16)

            // DATA sub-chunk
            writeString('data');
            writeUint32(numSamples * numChannels * bytesPerSample);

            // Write PCM data
            for (let i = 0; i < numSamples; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = Math.max(-1, Math.min(1, audioBuffer.getChannelData(channel)[i]));
                    // Convert float to 16-bit signed integer
                    const s = Math.round(sample * (32767));
                    view.setInt16(offset, s, true);
                    offset += 2;
                }
            }

            return new Blob([view], { type: 'audio/wav' });
        }


        // --- Initial Setup and Event Listeners ---
        window.addEventListener('load', () => {
            initAudioContext();
            initWebMidi();
            addSequencer(); // Add one sequencer by default on load
            addDelayInstance(); // Add one default delay instance
            applySkin(skinSelection.value); // Apply default skin
            setupCollapsibles(); // Initialize collapsible sections

            // Initial updates for controls
            updateChorusControls();
            updateFlangerControls();
            updatePhaserControls();
            updateReverbControls();
            // Delay controls are updated when instances are added/loaded
            updateHumanizerControls();
        });

        globalPlayStopButton.addEventListener('click', toggleGlobalPlayStop);
        addSequencerButton.addEventListener('click', addSequencer);
        generateBeatsButton.addEventListener('click', generateRandomBeats);
        tempoBPMInput.addEventListener('change', updateGlobalTempo);
        tapTempoButton.addEventListener('click', handleTapTempo);
        skinSelection.addEventListener('change', (event) => applySkin(event.target.value));
        globalMidiOutDeviceSelect.addEventListener('change', handleGlobalMidiDeviceChange);
        saveSettingsButton.addEventListener('click', saveSettings);
        loadSettingsFile.addEventListener('change', loadSettingsFromFile);
        demoSequencesSelect.addEventListener('change', loadDemoSequence);
        saveMidiButton.addEventListener('click', saveToMidi);
        saveWavButton.addEventListener('click', saveToWav);

        // Master Volume slider update
        masterVolumeSlider.addEventListener('input', () => {
            masterGainNode.gain.value = parseFloat(masterVolumeSlider.value);
            masterVolumeValueSpan.textContent = `${(masterGainNode.gain.value * 100).toFixed(0)}%`;
        });
        loopBeatsInput.addEventListener('change', updateGlobalLoopBeats);

        // Chorus Controls Handlers
        chorusRateSlider.addEventListener('input', updateChorusControls);
        chorusDepthSlider.addEventListener('input', updateChorusControls);
        chorusFeedbackSlider.addEventListener('input', updateChorusControls);
        chorusMixSlider.addEventListener('input', updateChorusControls);
        chorusOnOffButton.addEventListener('click', toggleChorus);

        // Flanger Controls Handlers
        flangerRateSlider.addEventListener('input', updateFlangerControls);
        flangerDepthSlider.addEventListener('input', updateFlangerControls);
        flangerFeedbackSlider.addEventListener('input', updateFlangerControls);
        flangerMixSlider.addEventListener('input', updateFlangerControls);
        flangerOnOffButton.addEventListener('click', toggleFlanger);

        // Phaser Controls Handlers
        phaserRateSlider.addEventListener('input', updatePhaserControls);
        phaserDepthSlider.addEventListener('input', updatePhaserControls);
        phaserFeedbackSlider.addEventListener('input', updatePhaserControls);
        phaserFrequencySlider.addEventListener('input', updatePhaserControls);
        phaserStagesInput.addEventListener('change', updatePhaserControls); // 'change' for number input
        phaserMixSlider.addEventListener('input', updatePhaserControls);
        phaserOnOffButton.addEventListener('click', togglePhaser);


        // Reverb Controls Handlers
        reverbAmountSlider.addEventListener('input', updateReverbControls);
        reverbDecaySlider.addEventListener('input', updateReverbControls);
        reverbDiffusionSlider.addEventListener('input', updateReverbControls);
        reverbLowpassSlider.addEventListener('input', updateReverbControls);
        reverbHighpassSlider.addEventListener('input', updateReverbControls); // NEW
        reverbOnOffButton.addEventListener('click', toggleReverb);
        reverbTypeSelect.addEventListener('change', updateReverbControls);

        // Add Delay button handler
        addDelayButton.addEventListener('click', () => addDelayInstance());

        // Humanizer Controls Handlers
        humanizerOnOffButton.addEventListener('click', toggleHumanizer);
        humanizeTimingSlider.addEventListener('input', updateHumanizerControls);
        humanizeVelocitySlider.addEventListener('input', updateHumanizerControls);
        humanizePanSlider.addEventListener('input', updateHumanizerControls);

        // Selected Circle Controls Handlers (NEW)
        circleXPositionInput.addEventListener('change', (event) => {
            if (selectedCircle.sequencer && selectedCircle.circleIndex !== -1) {
                selectedCircle.sequencer.updateCircleXPosition(event.target.value);
            }
        });
        circleXRatioInput.addEventListener('change', (event) => {
            if (selectedCircle.sequencer && selectedCircle.circleIndex !== -1) {
                selectedCircle.sequencer.updateCircleXRatio(event.target.value);
            }
        });
        circleVelocitySlider.addEventListener('input', () => {
            if (selectedCircle.sequencer && selectedCircle.circleIndex !== -1) {
                const circle = selectedCircle.sequencer.circles[selectedCircle.circleIndex];
                circle.velocity = parseInt(circleVelocitySlider.value);
                circleVelocityValueSpan.textContent = circle.velocity;
                selectedCircle.sequencer.draw(); // Redraw affected sequencer
            }
        });
        circlePanSlider.addEventListener('input', () => {
            if (selectedCircle.sequencer && selectedCircle.circleIndex !== -1) {
                const circle = selectedCircle.sequencer.circles[selectedCircle.circleIndex];
                circle.pan = parseFloat(circlePanSlider.value) / 100; // Convert -100 to 100 to -1 to 1
                circlePanValueSpan.textContent = parseInt(circlePanSlider.value);
                selectedCircle.sequencer.draw(); // Redraw affected sequencer
            }
        });

        // Global keyboard listener for edit modes AND spacebar for global play/stop (NEW)
        document.addEventListener('keydown', (event) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.tagName === 'BUTTON') {
                return; // Don't interfere with typing in inputs, selects, or button presses
            }

            let modeToSet = null;
            if (event.key === 'a' || event.key === 'A') {
                modeToSet = 'add';
            } else if (event.key === 's' || event.key === 'S') {
                modeToSet = 'edit';
            } else if (event.key === 'd' || event.key === 'D') {
                modeToSet = 'delete';
            } else if (event.key === ' ') { // Spacebar for global play/stop
                event.preventDefault(); // Prevent scrolling down
                toggleGlobalPlayStop();
                return; // Exit after handling spacebar
            }

            if (modeToSet) {
                activeSequencers.forEach(seq => {
                    seq.editMode = modeToSet;
                    if (seq.editModeSelect) { // Ensure the select element exists
                        seq.editModeSelect.value = modeToSet;
                    }
                    if (modeToSet === 'add' || modeToSet === 'delete') {
                        seq.deselectCircle(); // Close controls if not in edit mode
                    }
                    seq.draw(); // Redraw all sequencers to reflect mode changes (e.g., cursor)
                });
                console.log(`Global edit mode set to: ${modeToSet}`);
            }
        });
    </script>
</body>
</html>
